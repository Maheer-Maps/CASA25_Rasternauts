<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Nepal Landslides Risk Application</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./images/landslide_icon.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-86daaaaad7353f9cc0c554efc1dd6d94.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-47e95e32649f5ea4ff250a3e176ad85f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<style>

      .quarto-title-block .quarto-title-banner {
        background-image: url(images/nepal.png);
background-size: cover;
      }
</style>


<link rel="stylesheet" href="style_gen.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Nepal Landslides Risk Application</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#project-summary" id="toc-project-summary" class="nav-link active" data-scroll-target="#project-summary">Project Summary</a>
  <ul class="collapse">
  <li><a href="#problem-statement" id="toc-problem-statement" class="nav-link" data-scroll-target="#problem-statement">Problem Statement</a></li>
  <li><a href="#end-user" id="toc-end-user" class="nav-link" data-scroll-target="#end-user">End User</a></li>
  </ul></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology">Methodology</a>
  <ul class="collapse">
  <li><a href="#susceptibility-model" id="toc-susceptibility-model" class="nav-link" data-scroll-target="#susceptibility-model">Susceptibility Model</a></li>
  <li><a href="#random-forest-model" id="toc-random-forest-model" class="nav-link" data-scroll-target="#random-forest-model">Random Forest Model</a></li>
  </ul></li>
  <li><a href="#interface" id="toc-interface" class="nav-link" data-scroll-target="#interface">Interface</a></li>
  <li><a href="#the-application" id="toc-the-application" class="nav-link" data-scroll-target="#the-application">The Application</a>
  <ul class="collapse">
  <li><a href="#how-it-works" id="toc-how-it-works" class="nav-link" data-scroll-target="#how-it-works">How it Works</a></li>
  <li><a href="#demo" id="toc-demo" class="nav-link" data-scroll-target="#demo">Demo</a></li>
  <li><a href="#key-features-beyond-the-demo" id="toc-key-features-beyond-the-demo" class="nav-link" data-scroll-target="#key-features-beyond-the-demo">Key Features Beyond the Demo</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<section id="project-summary" class="level2">
<h2 class="anchored" data-anchor-id="project-summary">Project Summary</h2>
<p>The project aims to develop an application using Google Earth Engine that policymakers can use to assess the landslide susceptibility in Nepal. The model identifies high hazard zones by using parameters like terrain, hydrology, soil, and land cover data. The model follows methodologies from “Use of satellite remote sensing data in the mapping of global landslide susceptibility” by Hong et al (2007). The machine learning model is also tested to validate its accuracy and practicality using the recent landslide points data from the <a href="https://bipadportal.gov.np/incidents/">Bipad Portal</a> (Dates: 6-13 April, 2025).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://link.springer.com/article/10.1007/s11069-006-9104-z"><img src="images/hongetal.png" class="img-fluid figure-img" alt="Global Modelling by Hong et al., 2007"></a></p>
<figcaption>Global Modelling by Hong et al., 2007</figcaption>
</figure>
</div>
<hr>
<section id="problem-statement" class="level3">
<h3 class="anchored" data-anchor-id="problem-statement">Problem Statement</h3>
<p>Almost 80% of the total area of Nepal is prone to landslides (Department of Water Induced Disaster Prevention, 2015), so easily accessible research into which areas are most susceptible is motivated. Updating research to find which factors make areas most vulnerable to damaging landslides in Nepal provides information on the locations of vulnerable populations and critical infrastructure. This research must be easily interpretable for academics and, crucially, local administrators. Our application aims to bridge this disconnect by providing an accessible, Nepali-language platform for policymakers, planners, and stakeholders to visualize high susceptibility zones, and make informed decisions for mitigation and resilience.</p>
</section>
<section id="end-user" class="level3">
<h3 class="anchored" data-anchor-id="end-user">End User</h3>
<p>Our platform is designed for hybrid users across academia and specific administrative bodies involved in landslide management in Nepal. These users require scientifically robust yet accessible tools to develop policies. In the past, the gap between academic knowledge and local awareness limited the practical benefits of research—as seen during the 2015 earthquake and 2021 Melamchi floods. By delivering these models through a Nepali default website rather than papers, we aim to improve accessibility, utility, and real-world impact for those affected by landslides and responsible for crisis response.</p>
</section>
</section>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<table>
<tbody><tr>
<th>
Category
</th>
<th>
Dataset
</th>
<th>
Description
</th>
<th>
Source
</th>
</tr>
<tr>
<td rowspan="6">
GEE
</td>
<td>
Elevation/Slope
</td>
<td class="description">
NASA SRTM Digital Elevation 30m
</td>
<td>
<a href="https://developers.google.com/earth-engine/datasets/catalog/USGS_SRTMGL1_003">Link</a>
</td>
</tr>
<tr>
<td>
Land Cover
</td>
<td class="description">
MODIS Land Cover Type (2020)
</td>
<td>
<a href="https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MCD12Q1">Link</a>
</td>
</tr>
<tr>
<td>
Hydrology
</td>
<td class="description">
WWF HydroSHEDS flow accumulation
</td>
<td>
<a href="https://developers.google.com/earth-engine/datasets/catalog/WWF_HydroSHEDS_15ACC">Link</a>
</td>
</tr>
<tr>
<td>
Soil Texture
</td>
<td class="description">
OpenLandMap Soil Texture Class (USDA System)
</td>
<td>
<a href="https://developers.google.com/earth-engine/datasets/catalog/OpenLandMap_SOL_SOL_TEXTURE-CLASS_USDA-TT_M_v02">Link</a>
</td>
</tr>
<tr>
<td>
Soil Type
</td>
<td class="description">
OpenLandMap Clay Content
</td>
<td>
<a href="https://developers.google.com/earth-engine/datasets/catalog/OpenLandMap_SOL_SOL_CLAY-WFRACTION_USDA-3A1A1A_M_v02">Link</a>
</td>
</tr>
<tr>
<td>
Population Density
</td>
<td class="description">
Global Human Settlement Layer of spatial distribution of residential population
</td>
<td>
<a href="https://developers.google.com/earth-engine/datasets/catalog/JRC_GHSL_P2023A_GHS_POP">Link</a>
</td>
</tr>
<tr>
<td rowspan="4">
Other
</td>
<td>
Historical Landslides
</td>
<td class="description">
Official reported landslide incident points (2011 - April 2025)
</td>
<td>
<a href="https://bipadportal.gov.np/incidents/">Link</a>
</td>
</tr>
<tr>
<td>
Census Population
</td>
<td class="description">
Official Population per District 2021 Census
</td>
<td>
<a href="https://censusnepal.cbs.gov.np/results/population#population_size_and_distribution">Link</a>
</td>
</tr>
<tr>
<td>
Country Boundary
</td>
<td class="description">
Official boundary layer for Nepal
</td>
<td>
<a href="https://nationalgeoportal.gov.np/#/metadata/96">Link</a>
</td>
</tr>
<tr>
<td>
Districts Boundaries
</td>
<td class="description">
Official bouundaries of Nepal’s 77 districts
</td>
<td>
<a href="https://nationalgeoportal.gov.np/#/metadata/95p">Link</a>
</td>
</tr>
</tbody></table>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<section id="susceptibility-model" class="level3">
<h3 class="anchored" data-anchor-id="susceptibility-model">Susceptibility Model</h3>
<p>To recreate Hong et al.’s susceptibility model in GEE, we imported six environmental variables into a weighted linear combination. Each variable was normalized on a 0-1 scale, and in combination with the weights provided a susceptibility score for each pixel. Susceptibility was then normalized 0-1 for the whole of Nepal.</p>
<p><img src="images/Flowchart1.png" class="img-fluid" alt="Susceptibility Model Methodology"> <!--
#### Susceptibility Model Code
::: {.scroll-container style="overflow-y: scroll; height: 400px; padding:20px "}
``` javascript
 // Import shapefile for country boundaries
var filteredCountries = ee.FeatureCollection("projects/ee-testing-casa-25/assets/Nepal_boundary");
Map.centerObject(filteredCountries, 7);

// DEM
var dem = ee.Image('USGS/SRTMGL1_003');
var clippedDem = dem.clip(filteredCountries);

// Variable 1: SLOPE
var slope = ee.Terrain.slope(clippedDem);
var minMaxSlope = slope.reduceRegion({
  reducer: ee.Reducer.minMax(),
  geometry: filteredCountries.geometry(),
  scale: 250,
  bestEffort: true
});
var minSlope = ee.Number(minMaxSlope.get('slope_min'));
var maxSlope = ee.Number(minMaxSlope.get('slope_max'));

var normSlope = slope.subtract(minSlope).divide(maxSlope.subtract(minSlope));
Map.addLayer(normSlope, {min: 0, max: 1, palette: ['white', 'blue', 'green', 'yellow', 'red']}, 'Nomalised Slope', false);

// Variable 2: ELEVATION
var elev = clippedDem;
var minMaxElevation = elev.reduceRegion({
  reducer: ee.Reducer.minMax(),
  geometry: filteredCountries.geometry(),
  scale: 250,
  bestEffort: true
});
var minElev = ee.Number(minMaxElevation.get('elevation_min'));
var maxElev = ee.Number(minMaxElevation.get('elevation_max'));

var normElev = elev.subtract(minElev).divide(maxElev.subtract(minElev));
Map.addLayer(normElev, {min: 0, max: 1, palette: ['white', 'blue', 'green', 'yellow', 'red']}, 'Nomalised Elevation', false);

// Variable 3: MODIS land cover type and reclassification
var landcover = ee.ImageCollection("MODIS/061/MCD12Q1")
  .select("LC_Type1")
  .filterDate("2023-01-01", "2023-12-31")
  .first()
  .clip(filteredCountries);

var reclassifiedLand = landcover.remap(
  [0, 15, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 13, 17],
  [0, 0, 0.1, 0.1, 0.1, 0.2, 0.2, 0.3, 0.4, 0.4, 0.5, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0]
);

var minMaxLand = reclassifiedLand.reduceRegion({
  reducer: ee.Reducer.minMax(),
  geometry: filteredCountries.geometry(),
  scale: 250,
  bestEffort: true
});
var minLand = ee.Number(minMaxLand.get('remapped_min'));
var maxLand = ee.Number(minMaxLand.get('remapped_max'));

Map.addLayer(reclassifiedLand, {min: 0, max: 1, palette: ['blue', 'green', 'yellow', 'red']}, "Reclassified Land Cover", false);

// Variable 4a: Drainage Density
var flowAccum = ee.Image("WWF/HydroSHEDS/15ACC").clip(filteredCountries);
var kernel = ee.Kernel.circle(5000, 'meters');
var threshold = 50;
var streamMask = flowAccum.gt(threshold);
var drainageDensity = streamMask.reduceNeighborhood({
  reducer: ee.Reducer.mean(),
  kernel: kernel
});
var minMaxDensity = drainageDensity.reduceRegion({
  reducer: ee.Reducer.minMax(),
  geometry: filteredCountries.geometry(),
  scale: 250,
  bestEffort: true
});
var minDensity = ee.Number(minMaxDensity.get('b1_mean_min'));
var maxDensity = ee.Number(minMaxDensity.get('b1_mean_max'));

var normalizedDrainageDensity = drainageDensity.subtract(minDensity).divide(maxDensity.subtract(minDensity));
Map.addLayer(normalizedDrainageDensity, {min: 0, max: 1, palette: ['white', 'green', 'blue']}, 'Normalised Drainage Density', false);

// Variable 4b: Distance to Drainage
var streams = flowAccum.gt(threshold).selfMask();
var distanceToDrainage = streams.fastDistanceTransform().sqrt().clip(filteredCountries);
var minMax = distanceToDrainage.reduceRegion({
  reducer: ee.Reducer.minMax(),
  geometry: filteredCountries.geometry(),
  scale: 250,
  bestEffort: true
});
var minDist = ee.Number(minMax.get('distance_min'));
var maxDist = ee.Number(minMax.get('distance_max'));

var normalizedDistance = distanceToDrainage.subtract(minDist).divide(maxDist.subtract(minDist));
normalizedDistance = ee.Image(1).subtract(normalizedDistance);
Map.addLayer(normalizedDistance, {min: 0, max: 1, palette: ["blue", "yellow", "red"]}, "Normalized Distance to Drainage", false);

// Variable 5: Soil Texture (Original)
var soilTexture = ee.Image("OpenLandMap/SOL/SOL_TEXTURE-CLASS_USDA-TT_M/v02").select("b0").clip(filteredCountries);
var reclassifiedSoil = soilTexture.remap(
 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
 [3, 3, 3, 3, 2, 2, 2, 2, 1, 2, 1, 1]
);
reclassifiedSoil = ee.Image(4).subtract(reclassifiedSoil);
var minMaxSoilTexture = reclassifiedSoil.reduceRegion({
 reducer: ee.Reducer.minMax(),
 geometry: filteredCountries.geometry(),
 scale: 250,
 bestEffort: true
});

var minSoil = ee.Number(minMaxSoilTexture.get('constant_min'));
var maxSoil = ee.Number(minMaxSoilTexture.get('constant_max'));

var normalizedSoilTexture = reclassifiedSoil.subtract(minSoil).divide(maxSoil.subtract(minSoil));
Map.addLayer(normalizedSoilTexture, {min: 0, max: 1, palette: ["yellow", "green", "red"]}, "Normalised Soil Texture", false);

// Variable 6: Soil Type (Clay %)
var soilType = ee.Image("OpenLandMap/SOL/SOL_CLAY-WFRACTION_USDA-3A1A1A_M/v02").clip(filteredCountries);
soilType = soilType.reduce(ee.Reducer.mean());
var minMaxClay = soilType.reduceRegion({
  reducer: ee.Reducer.minMax(),
  geometry: filteredCountries.geometry(),
  scale: 250,
  bestEffort: true
});

var minClay = ee.Number(minMaxClay.get('mean_min'));
var maxClay = ee.Number(minMaxClay.get('mean_max'));

var normClay = soilType.subtract(minClay).divide(maxClay.subtract(minClay));
Map.addLayer(normClay.select(0), {min: 0, max: 1, palette: ["blue", "yellow", "red"]}, "Normalized Clay Percentage", false);

// Resample all layers
var targetScale = 1000;
var crs = 'EPSG:4326';
normSlope = normSlope.reproject({crs: crs, scale: targetScale});
normalizedDrainageDensity = normalizedDrainageDensity.reproject({crs: crs, scale: targetScale});
normalizedDistance = normalizedDistance.reproject({crs: crs, scale: targetScale});
normElev = normElev.reproject({crs: crs, scale: targetScale});
normClay = normClay.reproject({crs: crs, scale: targetScale});
reclassifiedLand = reclassifiedLand.reproject({crs: crs, scale: targetScale});
normalizedSoilTexture = normalizedSoilTexture.reproject({crs: crs, scale: targetScale});

// Landslide Susceptibility Model
var landslideRisk = normSlope.multiply(0.3)
  .add(normalizedDrainageDensity.multiply(0.1))
  // .add(normalizedDistance.multiply(0.1)) // optional
  .add(normElev.multiply(0.1))
  .add(normClay.multiply(0.2))
  .add(reclassifiedLand.multiply(0.1))
  .add(normalizedSoilTexture.multiply(0.2));

// Rename the band to "risk"
var landslideRisk = landslideRisk.rename('risk');

var minMaxRiskLandslide = landslideRisk.reduceRegion({
  reducer: ee.Reducer.minMax(),
  geometry: filteredCountries.geometry(),
  scale: 250,
  bestEffort: true
});

var minRisk = ee.Number(minMaxRiskLandslide.get('risk_min'));
var maxRisk = ee.Number(minMaxRiskLandslide.get('risk_max'));
var normalizedLandslideRisk = landslideRisk.subtract(minRisk).divide(maxRisk.subtract(minRisk));

Map.addLayer(normalizedLandslideRisk.select(0), {
  min: 0,
  max: 1,
  palette: ['green', 'yellow', 'red']
}, "Normalized Landslide Risk");
```
:::
--></p>
</section>
<section id="random-forest-model" class="level3">
<h3 class="anchored" data-anchor-id="random-forest-model">Random Forest Model</h3>
<p>To find populated areas most susceptible to landslides, we masked our environmental variables to populated areas, and trained a random forest classifier on landslide and randomly generated non-landslide points from Bipad Portal. Each pixel was scored based on the proportion of decision trees voting landslide.</p>
<p><img src="images/Flowchart2.png" class="img-fluid" alt="Random Forest Model Methodology"> <!--
#### Random Forest Model Code
::: {.scroll-container style="overflow-y: scroll; height: 400px; padding:20px "}
``` javascript

// Population Integration

// Load the Global Human Settlement Layer (GHSL) Population ImageCollection
var ghslPop = ee.ImageCollection('JRC/GHSL/P2023A/GHS_POP');

// Select the image corresponding to the year 2020 (index 9 in the collection)
var pop2020 = ghslPop.toList(12).get(9);
// Extract the 'population_count' band and clip it to Nepal's boundary
var popImage = ee.Image(pop2020).select('population_count').clip(NepalBoundary);


// Reproject the population image to 1 km resolution and EPSG:4326 to ensure alignment with the landslide susceptibility model
var pop1km = popImage
  .reproject({
    crs: crs, // 'EPSG:4326' defined earlier 
    scale: targetScale // 1000 meters defined earlier
  })
  .clip(NepalBoundary);


//  Visualise the 1km population layer on the map
//   - Pixels with a population density ≥ 500 people/km² will appear fully red.
//   - Pixels with lower densities are stretched linearly between white (0) and red (500).
Map.addLayer(pop1km, {min: 0, max: 500, palette: ['white', 'blue', 'red']}, 'GHSL Population (1km)', false);

// Create a binary population mask
// 0: No population
// 1: Some population (any value > 0)
var popBinary = pop1km.gt(0)
  .rename('popBinary')  // rename band for clarity
  .clip(NepalBoundary);

// Add the binary layer to the map
Map.addLayer(popBinary, {
  min: 0,
  max: 1,
  palette: ['white', 'red']
}, 'Binary Population Mask (0/1)', false);

// Visualise the susceptibility model that excludes unpopulated regions

// Mask landslide risk to populated areas only
var populatedRisk = landslideRisk.updateMask(popBinary);

// Recompute min and max values after masking
var minMaxPopulatedRisk = populatedRisk.reduceRegion({
  reducer: ee.Reducer.minMax(),
  geometry: NepalBoundary.geometry(),
  scale: 1000,
  bestEffort: true
});

// Extract new min and max
var minRiskPop = ee.Number(minMaxPopulatedRisk.get('risk_min'));
var maxRiskPop = ee.Number(minMaxPopulatedRisk.get('risk_max'));


// Re-normalise the masked risk layer
var normalizedPopulatedRisk = populatedRisk.subtract(minRiskPop)
  .divide(maxRiskPop.subtract(minRiskPop))
  .rename('risk');

// Add the new population-masked susceptibility map to the map
Map.addLayer(normalizedPopulatedRisk, {
  min: 0,
  max: 1,
  palette: ['green', 'yellow', 'red']
}, 'Normalized Landslide Risk (Populated Areas Only)', false);

// Machine Learning & Evaluation (Dan)

// 1. Classify landslide susceptibility zones
// select the first band once and use it everywhere
var risk = normalizedLandslideRisk.select(0);

// calculate percentiles (tertiles)
var susceptibilityPercentiles = risk.reduceRegion({
  reducer: ee.Reducer.percentile([33, 66]),
  geometry: NepalBoundary.geometry(),
  scale: 250,
  bestEffort: true
});

// extract break values
var p33 = ee.Number(susceptibilityPercentiles.get('risk_p33'));
var p66 = ee.Number(susceptibilityPercentiles.get('risk_p66'));

// reclassify ones based on percentiles
var susceptibilityZones = normalizedLandslideRisk
  .where(normalizedLandslideRisk.lt(p33), 1)
  .where(normalizedLandslideRisk.gte(p33).and(normalizedLandslideRisk.lt(p66)), 2)
  .where(normalizedLandslideRisk.gte(p66), 3)
  .rename('zone')
  .updateMask(normalizedLandslideRisk.mask())
  .clip(NepalBoundary);

// Visualise susceptibilityZones layer on the map
Map.addLayer(susceptibilityZones, {min: 1, max: 3, palette: ['green', 'yellow', 'red']}, 'Susceptibility Zones (Quantile)', false);

// Get pixel count per risk class
var classCounts = susceptibilityZones.reduceRegion({
  reducer: ee.Reducer.frequencyHistogram(),
  geometry: NepalBoundary.geometry(),
  scale: 250,
  bestEffort: true
});

// 2. Overlay landslide points onto Susceptibility Zones and Evaluate
// Source: https://bipadportal.gov.np/incidents/
var landslidePoints = ee.FeatureCollection("users/jihunnadi65/landslides_data_v1");

// Filter to include only points with reported damage
// Using only damaged landslides may not be optimal here, since our model aims to capture overall landslide susceptibility
// Including only damaged events could intrduce spatial bias for urban areas and compromise predictive power
// Instead, we retain all points for evaluation and use damage metrics as supplementary metadata
var damagedLandslidePoints = landslidePoints.filter(
  ee.Filter.or(
    ee.Filter.gt('peopleDeathCount', 0),
    ee.Filter.gt('peopleMissingCount', 0),
    ee.Filter.gt('peopleInjuredCount', 0),
    ee.Filter.gt('peopleAffectedCount', 0),
    ee.Filter.gt('infrastructureDestroyedCount', 0)
  )
);

// Optionally filter by year (e.g., to match land cover data or recent terrain condition)
// Filter from 2020 onwards reduces sample size from ~4300 to ~2670 points
// var recentLandslides = landslidePoints.filter(ee.Filter.gte('year', 2020));
// Map.addLayer(recentLandslides, {color: 'orange'}, 'Recent Landslides (2020–2025)');

// Visualise all known landslide points
// Total = 4,300 points (2011-05-14 to 2025-03-24)
Map.addLayer(landslidePoints, {pointSize: 5, color: 'red'}, 'Landslide Points', false);

// Visualise only landslide points with reported damage
// Total = 1,994 points in same date range
Map.addLayer(damagedLandslidePoints, {pointSize: 5, color: 'Orange'}, 'Damaged Landslide Points', false);

// Sample the susceptibility zone for each landslide point
// Using scale: 1000 to match the resolution of susceptibility raster (defined earlier as targetScale = 1000)
var validationSamples = susceptibilityZones.sampleRegions({
  collection: landslidePoints,
  scale: 1000, // match the resolution of susceptibility raster
  geometries: true // retain the original point geometry
});

// Count number of landslide points in each zone (low = 1, medium = 2, high = 3)
var pointCounts = validationSamples.reduceColumns({
  selectors: ['zone'],
  reducer: ee.Reducer.frequencyHistogram()
});

// Calculate proportions for comparion
var countsDict = ee.Dictionary(pointCounts.get('histogram'));
var totalPoints = countsDict.values().reduce(ee.Reducer.sum());
var proportions = countsDict.map(function(key, value) {
  return ee.Number(value).divide(totalPoints).multiply(100);
});

// Control test: Generate random points across Nepal to compare spatial bias
// This helps determine whether landslides fall in high-risk zones more than expected by chance
var randomPoints = ee.FeatureCollection.randomPoints({
  region: NepalBoundary.geometry(),
  points: landslidePoints.size(), // match number of real landslide points
  seed: 42 // use a fixed seed (42) to ensure reproducibility of random point generation across runs
});

// Sample susceptibility zone at random points
var randomSamples = susceptibilityZones.sampleRegions({
  collection: randomPoints,
  scale: 1000,
  geometries: true
});

// Histogram of real landslide zones
var realCounts = susceptibilityZones.sampleRegions({
  collection: landslidePoints,
  scale: 1000
}).reduceColumns({
  selectors: ['zone'],
  reducer: ee.Reducer.frequencyHistogram()
});

// Histogram of control group (random control points)
var randomCounts = randomSamples.reduceColumns({
  selectors: ['zone'],
  reducer: ee.Reducer.frequencyHistogram()
});


// 3.Chi-Square Test for Statistical Significance
// This test checks whether the distribution of landslide points across rik zones
// significantly differs from what would be expected by chance (random distribution)

// Extract observed (real) and expected (random) point distribution by zone
var realDict = ee.Dictionary(realCounts.get('histogram'));
var randomDict = ee.Dictionary(randomCounts.get('histogram'));


// Apply Chi-Square formula: sum((O - E)^2 / E) for each risk class
var keys = realDict.keys(); // ['1', '2', '3']
var chiSquare = keys.map(function(key) {
  key = ee.String(key);
  var observed = ee.Number(realDict.get(key));
  var expected = ee.Number(randomDict.get(key)).max(1); // prevision division by 0
  return observed.subtract(expected).pow(2).divide(expected);
});
var chiSquareTotal = chiSquare.reduce(ee.Reducer.sum());

// With 3 susceptibility classes, degree of freedom (df)= 2
// Reference critical values
// 95% confidence: 5.991, 99%: 9.210, 99.9%: 13.82
// Chi-square value of 835.16 is significantly higher than all reference thresholds for statistical significance

// 4. Binary Evaluation Using Confusion Matrix

// Build a Binary Confusion Matrix (High Risk = Zone 3, Not High Risk = Zone 1 + 2)
// Did a landslide point fall in a high-risk zone (True Positive)?
// Did a random (non-landslide) point fall in a high-risk zone (False Positive)?

// Assign class = 1 to actual landslide points
var realLabeled = susceptibilityZones.sampleRegions({
  collection: landslidePoints.map(function(f) {
    return f.set('label', 1); // positive class
  }),
  scale: 1000
});

// Assign class = 0 to random control points (no landslide)
var randomLabeled = susceptibilityZones.sampleRegions({
  collection: randomPoints.map(function(f) {
    return f.set('label', 0); // Negative class
  }),
  scale: 1000
});

// Combine all labeled points into one dataset
var allPoints = realLabeled.merge(randomLabeled);

// Generate binary predictions:
// Predicted = 1 if Zone 3 (high-risk); else 0
var predictions = allPoints.map(function(f) {
  var zone = ee.Number(f.get('zone'));
  var predicted = zone.eq(3); // binary risk
  return f.set('predicted', predicted);
});

// Compute confusion matrix: compares predicted vs actual labels
var confusion = predictions.errorMatrix('label', 'predicted');

// Extract underlying array from the error matrix
// [[TN, FP],
//  [FN, TP]]
var cmArray = ee.Array(confusion.array());

// Extract key elements from the matrix:
var TP = cmArray.get([1, 1]); // True Positive: correctly predicted landslide
var FP = cmArray.get([0, 1]); // False Positive: predicted landslide but no event
var FN = cmArray.get([1, 0]); // False Negative: missed actual landslide

// Compute Precision (Producer's Accuracy):
// Of all predicted landslides, what proportion were actual landslides?
var precision = TP.divide(TP.add(FP));

// Compute Recall (Consumer's Accuracy):
// Of all actual landslides, what proportion were correctly predicted?
var recall = TP.divide(TP.add(FN));

// Compute F1 Score:
// Harmonic mean of precision and recall, balances false positives and false negatives
// .max(1) avoids division by zero
var f1 = precision.multiply(recall).multiply(2).divide(precision.add(recall).max(1));



// Accuracy = 0.59 - The model correctly classified 59% of all validation points (landslide + non-landslide)
// Precision = 0.61 - Of all 1km² areas predicted as high-risk, 61% had a landslide
// Recall = 0.50 - The model correctly identified 50% of actual landslides (some were missed, falling in lower-risk zones)
// F1 Score = 0.55 - A balanced metric combining precision and recall, reflecting moderate overall predictive performance


// 5. Random Forest Classifier
// Assign class = 1 for known landslide points
var landslideLabeled = landslidePoints.map(function(f) {
  return f.set('class', 1); // positive class (landslide occurred)
});

// Generate random negative points with class = 0
var nonLandslidePoints = ee.FeatureCollection.randomPoints({
  region: NepalBoundary.geometry(),
  points: landslidePoints.size(), // match number as positive class for balanced training
  seed: 42 // set seed for reproducibility
}).map(function(f) {
  return f.set('class', 0); // negative class (assumed no landslide)
});

// Merge positive and negative samples into one training dataset
var trainingPoints = landslideLabeled.merge(nonLandslidePoints);

// Build feature stack of predictors
var featuresImage = ee.Image.cat([
  normSlope, // slope
  normalizedDrainageDensity, // drainage density
  // normalizedDistance, // optional
  normElev, // elevation
  normClay, // clay content
  reclassifiedLand, // reclassified MODIS land cover
  normalizedSoilTexture // reclassified soil texture
]).rename([
  'slope', 'drainDen', 'elev', 'clay', 'landcover', 'soiltex'
]);

// Sample predictor values at point locations
var training = featuresImage.sampleRegions({
  collection: trainingPoints,
  properties: ['class'], // target label
  scale: 1000 // match input raster resolution
});

// Train a Random Forest Classifier (50 trees)
var classifier = ee.Classifier.smileRandomForest(50).train({
  features: training,
  classProperty: 'class',
  inputProperties: ['slope', 'drainDen', 'elev', 'clay', 'landcover', 'soiltex']
});

// Apply classifier to raster to generate prediction map
var classified = featuresImage.classify(classifier);
Map.addLayer(classified, {min: 0, max: 1, palette: ['white', 'red']}, 'RF Landslide Prediction', false);
// white = low probability, red = high probability of landslide occurrences

// Create a probability classifier by setting output mode to PROBABILITY
var probabilityClassifier = classifier.setOutputMode('PROBABILITY');

// Classify the image with the probability classifier
var probabilityMap = featuresImage.classify(probabilityClassifier);

// Visualise the probability map (0 = low risk, 1 = high risk)
// This is more interpretable than just a binary yes/no map
Map.addLayer(probabilityMap, {
  min: 0,
  max: 1,
  palette: ['white', 'yellow', 'orange', 'red']
}, 'RF Landslide Probability', false);

// Accuracy Assessment
// Split training data into train/test sets using a random column
var withRandom = training.randomColumn('random'); // adds column 'random' between 0-1
var split = 0.7;
var trainSet = withRandom.filter(ee.Filter.lt('random', split)); // 70% for training
var valSet = withRandom.filter(ee.Filter.gte('random', split)); // 30% for validation

// Re-train on 70% subset
var trainedRF = ee.Classifier.smileRandomForest(50).train({
  features: trainSet,
  classProperty: 'class',
  inputProperties: ['slope', 'drainDen', 'elev', 'clay', 'landcover', 'soiltex']
});

// Filter out validation points with any null feature
// Classify the validation set using the re-trained RF model
var validated = valSet.filter(ee.Filter.notNull(['slope', 'drainDen', 'elev', 'clay', 'landcover', 'soiltex']))
                      .classify(trainedRF);
                      
// generate a confusion matrix by comparing true labels with predicted ones
var rfMatrix = validated.errorMatrix('class', 'classification');
// Extract array from RF confusion matrix
var rfArray = ee.Array(rfMatrix.array());

// Extract individual values for binary classification
var TP_rf = rfArray.get([1, 1]); // True Positive
var FP_rf = rfArray.get([0, 1]); // False Positive
var FN_rf = rfArray.get([1, 0]); // False Negative

// Precision = TP / (TP + FP)
// Of all areas predicted as high-risk, how many actually had landslides?
var precision_rf = TP_rf.divide(TP_rf.add(FP_rf));
// Recall = TP / (TP + FN)
// Of all actual landslides, how many were correctly predicted as high-risk?
var recall_rf = TP_rf.divide(TP_rf.add(FN_rf));
// F1 Score = 2 * (precision * recall) / (precision + recall)
// Balances the model’s ability to avoid false positives and false negatives
var f1_rf = precision_rf.multiply(recall_rf).multiply(2).divide(precision_rf.add(recall_rf).max(1));

// Variable Importance in RF Classifier (how useful each variable was in tree splits)
var importance = ee.Dictionary(classifier.explain().get('importance'));

// Convert variable importance dictionary to a FeatureCollection
var keys = importance.keys();

var importanceFeatures = keys.map(function(key) {
  key = ee.String(key);
  return ee.Feature(null, {
    variable: key,
    importance: ee.Number(importance.get(key))
  });
});

// Sort features by descending importance
var importanceFC = ee.FeatureCollection(importanceFeatures)
  .sort('importance', false);

// Build a horizontal bar chart usig the FeatureCollection
var chart = ui.Chart.feature.byFeature(importanceFC, 'variable', 'importance')
  .setChartType('BarChart')
  .setOptions({
    title: 'Random Forest Variable Importance',
    hAxis: {title: 'Importance'}, // x-axis: importance score
    vAxis: {title: 'Variable'}, // y-axis: variable names
    legend: 'none',
    fontSize: 12
  });

// ---------------------------------------------------------------------------------------------------

// Model Verification for Populated Areas Only (on damaged landslide points in populated areas) - Added 29/04/2025

// 1. Filter damaged landslides to only populated areas
var populatedMask = popBinary.selfMask();  // mask for populated pixels
var landslideInPopulated = landslidePoints.filterBounds(populatedMask.geometry());

var filteredPoints = popBinary.reduceRegions({
  collection: landslideInPopulated,
  reducer: ee.Reducer.first(),
  scale: 1000
}).filter(ee.Filter.eq('first', 1));  // keep only if pixel itself is populated

Map.addLayer(filteredPoints, {color: 'purple', pointSize: 5}, 'Landslides Points (Populated Areas)');

// 2. Sample susceptibility risk at those landslide points (in populated areas)
var populatedValidationSamples = normalizedPopulatedRisk.sampleRegions({
  collection: filteredPoints,
  scale: 1000,
  geometries: true
}).filter(ee.Filter.neq('risk', null));

var populatedPointRiskCounts = populatedValidationSamples.reduceColumns({
  selectors: ['risk'],
  reducer: ee.Reducer.histogram()
});

// 3. Compute population-specific percentiles
var populatedRiskPercentiles = normalizedPopulatedRisk.reduceRegion({
  reducer: ee.Reducer.percentile([33, 66]),
  geometry: NepalBoundary.geometry(),
  scale: 1000,
  bestEffort: true
});
var p33Pop = ee.Number(populatedRiskPercentiles.get('risk_p33'));
var p66Pop = ee.Number(populatedRiskPercentiles.get('risk_p66'));


// 4. Reclassify risk map into zones (1 = low, 2 = medium, 3 = high)
var populatedSusceptibilityZones = normalizedPopulatedRisk
  .where(normalizedPopulatedRisk.lt(p33Pop), 1)
  .where(normalizedPopulatedRisk.gte(p33Pop).and(normalizedPopulatedRisk.lt(p66Pop)), 2)
  .where(normalizedPopulatedRisk.gte(p66Pop), 3)
  .rename('zone')
  .updateMask(normalizedPopulatedRisk.mask())
  .clip(NepalBoundary);

Map.addLayer(populatedSusceptibilityZones, {min: 1, max: 3, palette: ['green', 'yellow', 'red']}, 'Populated Susceptibility Zones', true);

// 5. Sample zones at landslide points
var populatedValidationZones = populatedSusceptibilityZones.sampleRegions({
  collection: filteredPoints,
  scale: 1000,
  geometries: true
}).filter(ee.Filter.neq('zone', null));

var populatedPointCounts = populatedValidationZones.reduceColumns({
  selectors: ['zone'],
  reducer: ee.Reducer.frequencyHistogram()
});

// 6. Generate random points in Nepal and retain only those in populated pixels
var randomPopulatedPoints = ee.FeatureCollection.randomPoints({
  region: NepalBoundary.geometry(),
  points: filteredPoints.size(),
  seed: 42,
  maxError: 1
}).filterBounds(popBinary.geometry());

var randomPopulatedSamples = populatedSusceptibilityZones.sampleRegions({
  collection: randomPopulatedPoints,
  scale: 1000,
  geometries: true
}).filter(ee.Filter.neq('zone', null));

// 7. Frequency histogram comparison
var realPopulatedCounts = populatedValidationZones.reduceColumns({
  selectors: ['zone'],
  reducer: ee.Reducer.frequencyHistogram()
});
var randomPopulatedCounts = randomPopulatedSamples.reduceColumns({
  selectors: ['zone'],
  reducer: ee.Reducer.frequencyHistogram()
});

// 8. Chi-Square test: real vs random distribution
var realPopDict = ee.Dictionary(realPopulatedCounts.get('histogram'));
var randomPopDict = ee.Dictionary(randomPopulatedCounts.get('histogram'));
var keysPop = realPopDict.keys();

var chiSquarePop = keysPop.map(function(key) {
  key = ee.String(key);
  var observed = ee.Number(realPopDict.get(key));
  var expected = ee.Number(randomPopDict.get(key)).max(1);
  return observed.subtract(expected).pow(2).divide(expected);
});
var chiSquareTotalPop = chiSquarePop.reduce(ee.Reducer.sum());

// Binary Evaluation for Populated Areas Only

var populatedRealLabeled = populatedSusceptibilityZones.sampleRegions({
  collection: filteredPoints.map(function(f) {
    return f.set('label', 1);
  }),
  scale: 1000,
  geometries: true
}).filter(ee.Filter.neq('zone', null));

var populatedRandomLabeled = populatedSusceptibilityZones.sampleRegions({
  collection: randomPopulatedPoints.map(function(f) {
    return f.set('label', 0);
  }),
  scale: 1000,
  geometries: true
}).filter(ee.Filter.neq('zone', null));

var populatedAllPoints = populatedRealLabeled.merge(populatedRandomLabeled);

var populatedPredictions = populatedAllPoints.map(function(f) {
  var zone = ee.Number(f.get('zone'));
  var predicted = zone.eq(3);  // high risk
  return f.set('predicted', predicted);
});

var populatedConfusion = populatedPredictions.errorMatrix('label', 'predicted');

var cmArrayPop = ee.Array(populatedConfusion.array());
var TP_pop = cmArrayPop.get([1, 1]);
var FP_pop = cmArrayPop.get([0, 1]);
var FN_pop = cmArrayPop.get([1, 0]);

var precisionPop = TP_pop.divide(TP_pop.add(FP_pop));
var recallPop = TP_pop.divide(TP_pop.add(FN_pop));
var f1Pop = precisionPop.multiply(recallPop).multiply(2).divide(precisionPop.add(recallPop).max(1));

// Model Comparison Summary:
// - Chi-square value more than tripled (804.6 → 2562.9), indicating a much stronger statistical association between predicted high-risk zones and actual landslides occurring in populated areas.
// - Precision significantly improved (0.600 → 0.729), meaning the model's high-risk predictions are more trustworthy where people live.
// - Recall declined (0.504 → 0.480), indicating that a portion of actual landslides in populated areas still fall outside the predicted high-risk zone.
// - F1 Score increased (0.548 → 0.579), reflecting better overall balance between precision and recall.
// - Accuracy slightly declined (0.581 → 0.537), which is expected as unpopulated, low-risk areas (which are easy to classify) are excluded.
// Limiting evaluation to populated areas enhances the model’s relevance and precision for human-impact zones
// even if some events remain harder to capture. This prioritises decision-making where exposure is highest.

// Random Forest Classifier (Populated Areas Only)

// 1. Label landslide points
var populatedLandslidePoints = filteredPoints.map(function(f) {
  return f.set('class', 1);
});

// 2. Compute oversample factor based on area
var nepalArea = NepalBoundary.geometry().area().divide(1e6);  // in km²
var populatedPixelCount = popBinary.selfMask().reduceRegion({
  reducer: ee.Reducer.sum(),
  geometry: NepalBoundary.geometry(),
  scale: 1000,
  maxPixels: 1e13
}).get('popBinary');
var populatedArea = ee.Number(populatedPixelCount);  // each pixel ~ 1 km²
var oversampleFactor = nepalArea.divide(populatedArea).ceil();

// 3. Generate oversampled random points and mask to populated areas
var oversampledPoints = ee.FeatureCollection.randomPoints({
  region: NepalBoundary.geometry(),
  points: populatedLandslidePoints.size().multiply(oversampleFactor).int(),
  seed: 42,
  maxError: 1
});

var randomPopulatedPoints = popBinary.reduceRegions({
  collection: oversampledPoints,
  reducer: ee.Reducer.first(),
  scale: 1000
}).filter(ee.Filter.eq('first', 1))
  .limit(populatedLandslidePoints.size())
  .map(function(f) {
    return f.set('class', 0);
  });

// 4. Visual confirmation
Map.addLayer(populatedLandslidePoints, {color: 'red'}, 'Populated Landslide Points');
Map.addLayer(randomPopulatedPoints, {color: 'blue'}, 'Random Points in Populated Areas', false);

// 5. Training data and feature stack
var trainingPointsPopulated = populatedLandslidePoints.merge(randomPopulatedPoints);

var featuresImagePopulated = ee.Image.cat([
  normSlope,
  normalizedDrainageDensity,
  normElev,
  normClay,
  reclassifiedLand,
  normalizedSoilTexture
]).rename([
  'slope', 'drainDen', 'elev', 'clay', 'landcover', 'soiltex'
]).updateMask(popBinary);

var trainingPopulated = featuresImagePopulated.sampleRegions({
  collection: trainingPointsPopulated,
  properties: ['class'],
  scale: 1000,
  geometries: true
});

// 6. Train/test split
var withRandom = trainingPopulated.randomColumn('random');
var trainSetPop = withRandom.filter(ee.Filter.lt('random', 0.7));
var valSetPop = withRandom.filter(ee.Filter.gte('random', 0.7));

// 7. Train Random Forest model
var rfClassifierPop = ee.Classifier.smileRandomForest(50).train({
  features: trainSetPop,
  classProperty: 'class',
  inputProperties: ['slope', 'drainDen', 'elev', 'clay', 'landcover', 'soiltex']
});

// 8. Evaluate on validation set
var validatedPop = valSetPop
  .filter(ee.Filter.notNull(['slope', 'drainDen', 'elev', 'clay', 'landcover', 'soiltex']))
  .classify(rfClassifierPop);

var rfMatrixPop = validatedPop.errorMatrix('class', 'classification');
var rfArrayPop = ee.Array(rfMatrixPop.array());

var TP_rfPop = rfArrayPop.get([1, 1]);
var FP_rfPop = rfArrayPop.get([0, 1]);
var FN_rfPop = rfArrayPop.get([1, 0]);

var precision_rfPop = TP_rfPop.divide(TP_rfPop.add(FP_rfPop));
var recall_rfPop = TP_rfPop.divide(TP_rfPop.add(FN_rfPop));
var f1_rfPop = precision_rfPop.multiply(recall_rfPop).multiply(2).divide(precision_rfPop.add(recall_rfPop).max(1));

// 9. Apply classifier to image
var classifiedPopulated = featuresImagePopulated.classify(rfClassifierPop);
Map.addLayer(classifiedPopulated, {min: 0, max: 1, palette: ['white', 'red']}, 'RF Prediction (Populated Areas)');

// 10. Generate probability surface
var probabilityClassifierPop = rfClassifierPop.setOutputMode('PROBABILITY');
var probabilityMapPop = featuresImagePopulated.classify(probabilityClassifierPop);
Map.addLayer(probabilityMapPop, {
  min: 0,
  max: 1,
  palette: ['white', 'yellow', 'orange', 'red']
}, 'RF Probability (Populated Areas)');

// 11. Variable importance
var importancePop = ee.Dictionary(rfClassifierPop.explain().get('importance'));

var importanceFeaturesPop = importancePop.keys().map(function(key) {
  key = ee.String(key);
  return ee.Feature(null, {
    variable: key,
    importance: ee.Number(importancePop.get(key))
  });
});

var importanceFC = ee.FeatureCollection(importanceFeaturesPop).sort('importance', false);
var chartPop = ui.Chart.feature.byFeature(importanceFC, 'variable', 'importance')
  .setChartType('BarChart')
  .setOptions({
    title: 'Variable Importance (Populated Areas)',
    hAxis: {title: 'Importance'},
    vAxis: {title: 'Variable'},
    legend: 'none',
    fontSize: 12
  });

```
::: 

--></p>
</section>
</section>
<section id="interface" class="level2">
<h2 class="anchored" data-anchor-id="interface">Interface</h2>
<p>The website provides an intuitive, multilingual interface combining expertise and data into robust models, offering comparative visualizations and statistical summaries. The platform prioritizes clarity through map-based dashboards and toggleable language options to enhance accessibility and local impact.</p>
<div class="columns" data-layout-align="center">
<div class="column" style="width:46%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/UI_2.png" class="img-fluid figure-img"></p>
<figcaption>District Level View</figcaption>
</figure>
</div>
</div><div class="column" style="width:2%;">

</div><div class="column" style="width:46%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/UI_3.png" class="img-fluid figure-img"></p>
<figcaption>Methodology View</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="the-application" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-application">The Application</h2>
<section id="how-it-works" class="level3">
<h3 class="anchored" data-anchor-id="how-it-works">How it Works</h3>
<section id="data-preparation-and-precomputations" class="level4">
<h4 class="anchored" data-anchor-id="data-preparation-and-precomputations">1. Data Preparation and Precomputations</h4>
<p>To handle complex computations, separate scripts were developed for the two methodologies explained above. Results are imported into the app as precomputed layers.</p>
<p><strong>Imported Precomputed Layers:</strong></p>
<ul>
<li><p>Environmental Landslide Susceptibility: Maps susceptibility using environmental variables.</p></li>
<li><p>Normalized Landslide Susceptibility: Adjusted for population exposure.</p></li>
<li><p>Random Forest Landslide Probability: ML-based risk focused on populated areas.</p></li>
</ul>
<p><strong>District-Level Aggregation:</strong></p>
<p>A dedicated script was built to aggregate historical reported landslide data with impact metrics (e.g., incidents, deaths, injuries, destroyed infrastructure), alongside population and susceptibility metrics per district. It also includes engineered metrics such as incidents per km² and nearest districts (determined via spatial proximity of centroids) for comparative analysis.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript code-with-copy"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Compute distances to other districts and find two nearest neighbors using precomputed centroids</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> districtsWithDistance <span class="op">=</span> districtFactors<span class="op">.</span><span class="fu">map</span>(<span class="kw">function</span>(otherDistrict) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> otherName <span class="op">=</span> otherDistrict<span class="op">.</span><span class="fu">get</span>(<span class="st">'DISTRICT'</span>)<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> lon2 <span class="op">=</span> ee<span class="op">.</span><span class="fu">Number</span>(otherDistrict<span class="op">.</span><span class="fu">get</span>(<span class="st">'centroid_lon'</span>))<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> lat2 <span class="op">=</span> ee<span class="op">.</span><span class="fu">Number</span>(otherDistrict<span class="op">.</span><span class="fu">get</span>(<span class="st">'centroid_lat'</span>))<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Approximate distance using Euclidean distance in lat/lon </span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> distance <span class="op">=</span> lon1<span class="op">.</span><span class="fu">subtract</span>(lon2)<span class="op">.</span><span class="fu">pow</span>(<span class="dv">2</span>)<span class="op">.</span><span class="fu">add</span>(lat1<span class="op">.</span><span class="fu">subtract</span>(lat2)<span class="op">.</span><span class="fu">pow</span>(<span class="dv">2</span>))<span class="op">.</span><span class="fu">sqrt</span>()<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> otherDistrict<span class="op">.</span><span class="fu">set</span>(<span class="st">'distance'</span><span class="op">,</span> distance)<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> nearbyDistricts <span class="op">=</span> districtsWithDistance</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">filter</span>(ee<span class="op">.</span><span class="at">Filter</span><span class="op">.</span><span class="fu">neq</span>(<span class="st">'DISTRICT'</span><span class="op">,</span> districtName))</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">sort</span>(<span class="st">'distance'</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">limit</span>(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Extract the two nearest neighbors</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> neighbor1 <span class="op">=</span> nearbyDistricts<span class="op">.</span><span class="fu">first</span>()<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> neighbor2 <span class="op">=</span> nearbyDistricts<span class="op">.</span><span class="fu">toList</span>(<span class="dv">2</span>)<span class="op">.</span><span class="fu">get</span>(<span class="dv">1</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="interactive-visualization-and-analysis" class="level4">
<h4 class="anchored" data-anchor-id="interactive-visualization-and-analysis">2. Interactive Visualization and Analysis</h4>
</section>
<section id="national-overview" class="level4">
<h4 class="anchored" data-anchor-id="national-overview">National Overview</h4>
<p>At startup, national-level statistics are displayed, highlighting aggregated data. A pie chart shows population risk distribution across susceptibility zones (Low, Medium, High), and a bar chart lists the top 5 districts by impact metric, allowing users to switch metrics and zoom into a district by clicking a bar.</p>
<section id="susceptibility-zones" class="level5">
<h5 class="anchored" data-anchor-id="susceptibility-zones"><strong>susceptibility zones</strong></h5>
<p>Susceptibility zones are defined as Low (&lt;0.3), Medium (0.3–0.5), and High (&gt;0.5), identified by analyzing the distribution of susceptibility values from the built Susceptibility model.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript code-with-copy"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Generate a histogram of susceptibility values</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> histogram <span class="op">=</span> LandslideSusceptibility<span class="op">.</span><span class="fu">reduceRegion</span>({</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">reducer</span><span class="op">:</span> ee<span class="op">.</span><span class="at">Reducer</span><span class="op">.</span><span class="fu">histogram</span>({<span class="dt">min</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span> <span class="dt">max</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">steps</span><span class="op">:</span> <span class="dv">100</span>})<span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">geometry</span><span class="op">:</span> NepalBoundary<span class="op">.</span><span class="fu">geometry</span>()<span class="op">,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">scale</span><span class="op">:</span> <span class="dv">1000</span><span class="op">,</span> <span class="co">// Match the scale used in the app for consistency</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">maxPixels</span><span class="op">:</span> <span class="fl">1e10</span><span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bestEffort</span><span class="op">:</span> <span class="kw">true</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Extract the histogram data</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> histogramDict <span class="op">=</span> ee<span class="op">.</span><span class="fu">Dictionary</span>(histogram<span class="op">.</span><span class="fu">get</span>(<span class="st">'susceptibility'</span>))<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> values <span class="op">=</span> ee<span class="op">.</span><span class="fu">List</span>(histogramDict<span class="op">.</span><span class="fu">get</span>(<span class="st">'histogram'</span>))<span class="op">;</span> <span class="co">// Frequency counts</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> bucketEdges <span class="op">=</span> ee<span class="op">.</span><span class="fu">List</span>(histogramDict<span class="op">.</span><span class="fu">get</span>(<span class="st">'bucketMeans'</span>))<span class="op">;</span> <span class="co">// Bin centers</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Define susceptibility zones based on histogram-derived thresholds</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> thresholdZones <span class="op">=</span> LandslideSusceptibility</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">where</span>(LandslideSusceptibility<span class="op">.</span><span class="fu">lt</span>(<span class="fl">0.3</span>)<span class="op">,</span> <span class="dv">1</span>) <span class="co">// Low Risk: &lt; 0.3</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">where</span>(LandslideSusceptibility<span class="op">.</span><span class="fu">gte</span>(<span class="fl">0.3</span>)<span class="op">.</span><span class="fu">and</span>(LandslideSusceptibility<span class="op">.</span><span class="fu">select</span>(<span class="st">'slope'</span>)<span class="op">.</span><span class="fu">lte</span>(<span class="fl">0.5</span>))<span class="op">,</span> <span class="dv">2</span>) <span class="co">// Medium Risk: 0.3–0.5</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">where</span>(LandslideSusceptibility<span class="op">.</span><span class="fu">gt</span>(<span class="fl">0.5</span>)<span class="op">,</span> <span class="dv">3</span>) <span class="co">// High Risk: &gt; 0.5</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">rename</span>(<span class="st">'zone'</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">updateMask</span>(LandslideSusceptibility<span class="op">.</span><span class="fu">mask</span>())</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">clip</span>(NepalBoundary)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="district-level-analysis" class="level4">
<h4 class="anchored" data-anchor-id="district-level-analysis">District-Level Analysis:</h4>
<p>This view provides detailed district analysis, showing key metrics like average susceptibility, population, and incidents per km², alongside comparisons with national averages and the two nearest districts. Historical landslides are visualized on the map, with popups displaying aggregated details within a 300m radius of a clicked point.</p>
</section>
<section id="methodology-overview" class="level4">
<h4 class="anchored" data-anchor-id="methodology-overview">Methodology overview:</h4>
<p>This view allows users to compare the two methodologies (Environmental Susceptibility and RF) using a split panel. It displays the RF probability map and normalized risk map for populated areas, with a draggable divider for spatial comparison, focusing on population exposure.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript code-with-copy"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Initialize split maps with layers</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> leftMap <span class="op">=</span> ui<span class="op">.</span><span class="fu">Map</span>()<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> rightMap <span class="op">=</span> ui<span class="op">.</span><span class="fu">Map</span>()<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Add risk layers to split maps</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> leftProbabilityLayer <span class="op">=</span> ui<span class="op">.</span><span class="at">Map</span><span class="op">.</span><span class="fu">Layer</span>(probabilityLayer<span class="op">.</span><span class="fu">getEeObject</span>()<span class="op">,</span> probabilityLayer<span class="op">.</span><span class="fu">getVisParams</span>()<span class="op">,</span> <span class="fu">translate</span>(<span class="st">'RF Landslide Probability (Populated Areas)'</span>))<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>leftMap<span class="op">.</span><span class="fu">layers</span>()<span class="op">.</span><span class="fu">add</span>(leftProbabilityLayer)<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> rightNormalizedRiskLayer <span class="op">=</span> ui<span class="op">.</span><span class="at">Map</span><span class="op">.</span><span class="fu">Layer</span>(normalizedRiskLayer<span class="op">.</span><span class="fu">getEeObject</span>()<span class="op">,</span> normalizedRiskLayer<span class="op">.</span><span class="fu">getVisParams</span>()<span class="op">,</span> <span class="fu">translate</span>(<span class="st">'Landslide Susceptibility (Populated Areas)'</span>))<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>rightMap<span class="op">.</span><span class="fu">layers</span>()<span class="op">.</span><span class="fu">add</span>(rightNormalizedRiskLayer)<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Link maps for synchronized zooming and panning</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> mapLinker <span class="op">=</span> ui<span class="op">.</span><span class="at">Map</span><span class="op">.</span><span class="fu">Linker</span>([leftMap<span class="op">,</span> rightMap])<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Set up the split panel for comparison</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> splitPanel <span class="op">=</span> ui<span class="op">.</span><span class="fu">SplitPanel</span>({</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a> <span class="dt">firstPanel</span><span class="op">:</span> leftMap<span class="op">,</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a> <span class="dt">secondPanel</span><span class="op">:</span> rightMap<span class="op">,</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a> <span class="dt">orientation</span><span class="op">:</span> <span class="st">'horizontal'</span><span class="op">,</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a> <span class="dt">wipe</span><span class="op">:</span> <span class="kw">true</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="insights-and-objectives" class="level4">
<h4 class="anchored" data-anchor-id="insights-and-objectives">3. insights and objectives</h4>
<p>The app provides actionable insights for disaster preparedness in Nepal by identifying high-risk districts and population exposure. It supports:</p>
<ul>
<li><p>Risk Prioritization: Highlights districts with high susceptibility or incident rates (e.g., top 5 districts by deaths) to guide resource allocation.</p></li>
<li><p>Localized Insights: Enables district-level analysis for targeted planning and response, benefiting community preparedness efforts.</p></li>
<li><p>Academic Research: Unlike traditional landslide models in academic papers, this app provides an interactive platform for exploring risk dynamics through a comparison of Environmental Susceptibility and Random Forest methodologies, leveraging incidents data. By masking to populated areas, it focuses on human exposure, as official records often under-report incidents in uninhabited regions, ensuring more accurate risk assessment and model comparison for populated zones.</p></li>
</ul>
</section>
<section id="limitations-and-potential-expansion" class="level4">
<h4 class="anchored" data-anchor-id="limitations-and-potential-expansion"><strong>4. Limitations and Potential Expansion</strong></h4>
<ul>
<li><p><strong>Model Variables:</strong> The Environmental Susceptibility model uses six variables—slope, elevation, land cover, soil texture, clay content, and drainage density—with weights derived from literature. Future improvements could involve a more comprehensive literature review to identify additional influential factors and the integration of advanced modeling techniques.</p></li>
<li><p><strong>Static Models:</strong> Current models are precomputed, limiting adaptability to changing environmental conditions. Adding dynamic updates with live data (e.g., rainfall, land use changes) could improve accuracy and responsiveness.</p></li>
<li><p><strong>Granularity of Analysis:</strong> The app focuses on district-level analysis, but more granular insights (e.g., at the village or ward level) could improve localized planning</p></li>
<li><p><strong>Report Export:</strong> The app lacks a feature to export analysis reports, which would be valuable for stakeholders to document and share findings.</p></li>
</ul>
</section>
</section>
<section id="demo" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="demo">Demo</h3>
<p>The application runs on Google Earth Engine, allowing users to visualise landslide risk across Nepal dynamically. Users can zoom in to specific districts, interpret risk zones, and overlay incident data to validate model predictions. The tool is built for scalability and may be adapted for other regions facing similar geological threats.</p>
<div class="column-page">
<iframe src="https://ee-ajikumaraadarsh.projects.earthengine.app/view/nepallandslide" width="100%" height="800px">
</iframe>
</div>
</section>
<section id="key-features-beyond-the-demo" class="level3">
<h3 class="anchored" data-anchor-id="key-features-beyond-the-demo">Key Features Beyond the Demo</h3>
<p>While our demo showcases the app’s core functionality, several critical features work behind the scenes to enhance its performance and reliability. In this section, we highlight key capabilities implemented to optimize efficiency and ensure a seamless user experience.</p>
<div class="cell g-col-lg-6 g-col-12 g-col-md-12">
<div class="cell-output-display">
<div id="gallery-carousel" class="carousel carousel-dark slide" data-bs-ride="false" style="height: 700px; background-color: #f0f0f0; position: relative; width: 100%;">
<div class="carousel-indicators">
<button type="button" data-bs-target="#gallery-carousel" data-bs-slide-to="0" aria-label="Slide 1" class="active" aria-current="true"></button>
<button type="button" data-bs-target="#gallery-carousel" data-bs-slide-to="1" aria-label="Slide 2"></button>
<button type="button" data-bs-target="#gallery-carousel" data-bs-slide-to="2" aria-label="Slide 3"></button>
<button type="button" data-bs-target="#gallery-carousel" data-bs-slide-to="3" aria-label="Slide 4"></button>
<button type="button" data-bs-target="#gallery-carousel" data-bs-slide-to="4" aria-label="Slide 5"></button>
<button type="button" data-bs-target="#gallery-carousel" data-bs-slide-to="5" aria-label="Slide 6"></button>
<button type="button" data-bs-target="#gallery-carousel" data-bs-slide-to="6" aria-label="Slide 7"></button>
</div>
<div class="carousel-inner" style="height: 700px; width: 100%;">
<div class="carousel-item active" style="width: 100%; height: 100%; padding: 20px 70px; text-align: center; box-sizing: border-box;" data-bs-interval="5000">
<p class="carousel-title" style="padding: 0; color: #7b7f5f; font-size: 1.3em; font-family: 'News Cycle', 'Arial Narrow Bold', sans-serif; font-weight: bold; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Multi-Language Support</p>
<p class="fw-light" style="padding: 10px 0; color: #000; font-size: 0.7em; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Designed with the end user in mind, the app supports Nepal’s primary languages—Nepali (~44%), Maithili (~12%), and Bhojpuri (~6%)—ensuring accessibility for diverse users, including those with low English fluency.</p>
<div class="image-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<a href="">
<img src="images/App_multiLanguage.png" class="d-block" style="width: 100%;  max-height: 300px; height: auto; object-fit: contain; margin: 0 auto;">
</a>
</div>
<div class="code-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<div class="code-snippet" style="font-family: 'Courier New', monospace; font-size: 0.8em; background-color: #f5f5f5; padding: 8px; border-radius: 3px; width: 90%; height: 200px; overflow-y: auto; white-space: pre-wrap; text-align: left; margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">// Language selection dropdown
var languageSelect = ui.Select({
items: [
{label: 'English', value: 'English'},
{label: 'Nepali', value: 'Nepali'},
{label: 'Maithili', value: 'Maithili'},
{label: 'Bhojpuri', value: 'Bhojpuri'}
],
onChange: function(value) {
resetToNationalView();
updateLanguage(value);
}
});
/ Translation dictionary (Sample)
var LANGUAGE_TRANSLATIONS = {
'Nepali': { 'Click on the map or select from list:': 'नक्सामा क्लिक गर्नुहोस् वा सूचीबाट चयन गर्नुहोस्:' },
'Maithili': { 'Click on the map or select from list:': 'नक्शा पर क्लिक करू या सूची सँ चुनू' },
'Bhojpuri': { 'Click on the map or select from list:': 'नक्शा प क्लिक करीं या सूची से चुनीं' }
}; </div>
</div>
</div>
<div class="carousel-item" style="width: 100%; height: 100%; padding: 20px 70px; text-align: center; box-sizing: border-box;" data-bs-interval="5000">
<p class="carousel-title" style="padding: 0; color: #7b7f5f; font-size: 1.3em; font-family: 'News Cycle', 'Arial Narrow Bold', sans-serif; font-weight: bold; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Efficient Caching</p>
<p class="fw-light" style="padding: 10px 0; color: #000; font-size: 0.7em; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">To avoid redundant computations, the app Leverages local memory for server-side calculations, ensuring responsiveness even with large datasets.</p>
<div class="image-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<a href="">
<img src="images/App_cashing.png" class="d-block" style="width: 100%;  max-height: 300px; height: auto; object-fit: contain; margin: 0 auto;">
</a>
</div>
<div class="code-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<div class="code-snippet" style="font-family: 'Courier New', monospace; font-size: 0.8em; background-color: #f5f5f5; padding: 8px; border-radius: 3px; width: 90%; height: 200px; overflow-y: auto; white-space: pre-wrap; text-align: left; margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">// Cache national statistics at startup
ee.Dictionary({
incidentCount: districtFactors.aggregate_sum('incidentCount'),
deaths: districtFactors.aggregate_sum('deaths'),
injuries: districtFactors.aggregate_sum('injuries'),
infrastructureDestroyed: districtFactors.aggregate_sum('infraDestroyed')
}).evaluate(
function(values) {
// Cached values used in national overview for quick loading
nationalStats.incidentCount = Number(values.incidentCount) || 0; // Total incidents
nationalStats.deaths = Number(values.deaths) || 0; // Total deaths
nationalStats.injuries = Number(values.injuries) || 0; // Total injuries
nationalStats.infrastructureDestroyed = Number(values.infrastructureDestroyed) || 0; // Total infrastructure damage
initializeAppAfterCaching();
}
);</div>
</div>
</div>
<div class="carousel-item" style="width: 100%; height: 100%; padding: 20px 70px; text-align: center; box-sizing: border-box;" data-bs-interval="5000">
<p class="carousel-title" style="padding: 0; color: #7b7f5f; font-size: 1.3em; font-family: 'News Cycle', 'Arial Narrow Bold', sans-serif; font-weight: bold; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Robust Error Handling</p>
<p class="fw-light" style="padding: 10px 0; color: #000; font-size: 0.7em; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">The app handles clicks outside study areas and data issues with clear messages to keep users informed and engaged, preventing crashes and enhancing reliability.</p>
<div class="image-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<a href="">
<img src="images/App_outsideclick.png" class="d-block" style="width: 100%;  max-height: 300px; height: auto; object-fit: contain; margin: 0 auto;">
</a>
</div>
<div class="code-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<div class="code-snippet" style="font-family: 'Courier New', monospace; font-size: 0.8em; background-color: #f5f5f5; padding: 8px; border-radius: 3px; width: 90%; height: 200px; overflow-y: auto; white-space: pre-wrap; text-align: left; margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">// Handle clicks outside Nepal
NepalBoundary.geometry().contains(point).evaluate(function(isInside) {
if (!isInside) {
StatisticsPanel.clear();
var widgets = controlPanel.widgets();
if (widgets.indexOf(districtInstructionLabel) !== -1) {
widgets.remove(districtInstructionLabel);
}
if (widgets.indexOf(districtSelectPanel) !== -1) {
widgets.remove(districtSelectPanel);
}
StatisticsPanel.add(ui.Label(translate('Click outside Nepal boundary. Please select a point within Nepal.'), STYLES.SUBTITLE));
StatisticsPanel.add(ui.Button({
label: translate('Reset to National Overview'),
onClick: function() {
resetToNationalView();
},
style: { margin: '10px auto', stretch: 'horizontal', textAlign: 'center' }
}));
} });</div>
</div>
</div>
<div class="carousel-item" style="width: 100%; height: 100%; padding: 20px 70px; text-align: center; box-sizing: border-box;" data-bs-interval="5000">
<p class="carousel-title" style="padding: 0; color: #7b7f5f; font-size: 1.3em; font-family: 'News Cycle', 'Arial Narrow Bold', sans-serif; font-weight: bold; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Optimal Rendering</p>
<p class="fw-light" style="padding: 10px 0; color: #000; font-size: 0.7em; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">The app enhances speed and user experience by clipping and rendering high-resolution raster data for the selected district only, rather than the entire country.</p>
<div class="image-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<a href="">
<img src="images/App_clipping.png" class="d-block" style="width: 100%;  max-height: 300px; height: auto; object-fit: contain; margin: 0 auto;">
</a>
</div>
<div class="code-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<div class="code-snippet" style="font-family: 'Courier New', monospace; font-size: 0.8em; background-color: #f5f5f5; padding: 8px; border-radius: 3px; width: 90%; height: 200px; overflow-y: auto; white-space: pre-wrap; text-align: left; margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">// Highlight and clip layers for the selected district
function highlightDistrict(district) {
// Simplify geometry to reduce computation
var districtGeometry = district.geometry().simplify({maxError: 100});
// Clip layers to district for efficient rendering
var clippedLandslide = landslidePoints.filterBounds(districtGeometry);
var clippedSus = LandslideSusceptibility.clip(districtGeometry);

clippedLandslideFeatures = null;
clippedLandslide.evaluate(function(features) {
clippedLandslideFeatures = features.features || [];
});

clearMapLayersExceptHighlight();
// Add clipped layers to map
var susceptibilityLayerclip = ui.Map.Layer(clippedSus, {min: 0, max: 1, palette: [STYLES.COLORS.LOW_RISK, STYLES.COLORS.MEDIUM_RISK, STYLES.COLORS.HIGH_RISK]});
Map.layers().add(susceptibilityLayerclip);
}</div>
</div>
</div>
<div class="carousel-item" style="width: 100%; height: 100%; padding: 20px 70px; text-align: center; box-sizing: border-box;" data-bs-interval="5000">
<p class="carousel-title" style="padding: 0; color: #7b7f5f; font-size: 1.3em; font-family: 'News Cycle', 'Arial Narrow Bold', sans-serif; font-weight: bold; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Custom Basemaps and Streamlined Controls</p>
<p class="fw-light" style="padding: 10px 0; color: #000; font-size: 0.7em; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">The app enhances the user experience by customizing the basemap to focus on essential geographic data, modifying road displays (e.g., highways, arterial, and local roads) to reduce visual clutter and removing unneeded base elements like saturation. Additionally, main map controls (e.g., zoom, map type, scale, fullscreen) are hidden to provide a distraction-free interface.</p>
<div class="image-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<a href="">
<img src="images/App_basemap.png" class="d-block" style="width: 100%;  max-height: 300px; height: auto; object-fit: contain; margin: 0 auto;">
</a>
</div>
<div class="code-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<div class="code-snippet" style="font-family: 'Courier New', monospace; font-size: 0.8em; background-color: #f5f5f5; padding: 8px; border-radius: 3px; width: 90%; height: 200px; overflow-y: auto; white-space: pre-wrap; text-align: left; margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">// Customize basemap to reduce visual clutter
var roadNetwork = [
{stylers: [{saturation: -100}]}, // Desaturate basemap for focus on data layers
{featureType: 'road.highway', elementType: 'geometry.fill', stylers: [{color: '#000055'}, {weight: 0.1}]}, // Simplify highway display
{featureType: 'road.highway', elementType: 'geometry.stroke', stylers: [{color: '#000000'}, {weight: 0.1}]},
{featureType: 'road.arterial', elementType: 'geometry', stylers: [{color: '#FF0000'}, {weight: 0.1}]}, // Simplify arterial roads
{featureType: 'road.local', elementType: 'geometry', stylers: [{color: '#00FF55'}, {weight: 0.1}]} // Simplify local roads
];
Map.setOptions('roadNetwork', { roadNetwork: roadNetwork });

// Hide main map controls for a distraction-free interface
Map.setControlVisibility({
zoomControl: false, // Disable zoom control
mapTypeControl: false, // Disable map type selector
scaleControl: false, // Disable scale control
fullscreenControl: false // Disable fullscreen control
});
Map.drawingTools().setShown(false); // Hide drawing tools
</div>
</div>
</div>
<div class="carousel-item" style="width: 100%; height: 100%; padding: 20px 70px; text-align: center; box-sizing: border-box;" data-bs-interval="5000">
<p class="carousel-title" style="padding: 0; color: #7b7f5f; font-size: 1.3em; font-family: 'News Cycle', 'Arial Narrow Bold', sans-serif; font-weight: bold; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Summary Popups</p>
<p class="fw-light" style="padding: 10px 0; color: #000; font-size: 0.7em; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Clicking a landslide point in district view displays a popup with aggregated details, aiding understanding of past events at specific locations.</p>
<div class="image-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<a href="">
<img src="images/App_popup.png" class="d-block" style="width: 100%;  max-height: 300px; height: auto; object-fit: contain; margin: 0 auto;">
</a>
</div>
<div class="code-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<div class="code-snippet" style="font-family: 'Courier New', monospace; font-size: 0.8em; background-color: #f5f5f5; padding: 8px; border-radius: 3px; width: 90%; height: 200px; overflow-y: auto; white-space: pre-wrap; text-align: left; margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">// Detect landslide points within buffer and aggregate data
var clickRadius = 0.0027; // ~300 meters
var matchingFeatures = [];
clippedLandslideFeatures.forEach(function(feature) {
var featureCoords = feature.geometry.coordinates;
var distance = Math.sqrt(
Math.pow(clickLon - featureLon, 2) + Math.pow(clickLat - featureLat, 2)
);
if (distance &lt; clickRadius) {
matchingFeatures.push(feature);
}
});

if (matchingFeatures.length &gt; 0) {
var totalDeaths = 0, totalInjuries = 0, incidentCount = matchingFeatures.length;
matchingFeatures.forEach(function(feature) {
var props = feature.properties || {};
totalDeaths += props.peopleDeathCount || 0;
totalInjuries += props.peopleInjuredCount || 0;
});
showLandslidePopup({ incidentCount: incidentCount, totalDeaths: totalDeaths, totalInjuries: totalInjuries });
}

// Display aggregated data in popup
function showLandslidePopup(aggregatedData, coords) {
var titleTemplate = translate('Landslide Events ({0} Incidents)');
var title = titleTemplate.replace('{0}', aggregatedData.incidentCount);
contentPanel.add(ui.Label(title, { fontSize: '16px', fontWeight: 'bold' }));
contentPanel.add(createRow('Deaths:', aggregatedData.totalDeaths));
contentPanel.add(createRow('Injuries:', aggregatedData.totalInjuries));
}</div>
</div>
</div>
<div class="carousel-item" style="width: 100%; height: 100%; padding: 20px 70px; text-align: center; box-sizing: border-box;" data-bs-interval="5000">
<p class="carousel-title" style="padding: 0; color: #7b7f5f; font-size: 1.3em; font-family: 'News Cycle', 'Arial Narrow Bold', sans-serif; font-weight: bold; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Interactive Analysis</p>
<p class="fw-light" style="padding: 10px 0; color: #000; font-size: 0.7em; text-align: center; width: 100%;  margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">Users can interact with districts by clicking on the map, selecting from a dropdown, or using connected charts, enabling seamless data exploration.</p>
<div class="image-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<a href="">
<img src="images/App_interactivity.png" class="d-block" style="width: 100%;  max-height: 300px; height: auto; object-fit: contain; margin: 0 auto;">
</a>
</div>
<div class="code-row" style="padding: 10px 0; width: 100%;  text-align: center; margin: 0 auto; box-sizing: border-box;">
<div class="code-snippet" style="font-family: 'Courier New', monospace; font-size: 0.8em; background-color: #f5f5f5; padding: 8px; border-radius: 3px; width: 90%; height: 200px; overflow-y: auto; white-space: pre-wrap; text-align: left; margin: 0 auto; word-wrap: break-word; box-sizing: border-box;">// Chart interaction in national overview
topDistrictsChart.onClick(function(district) {
if (district) {
var originalDistrictName = district.toUpperCase();
selectDistrict(originalDistrictName);
}
});

// Alternative: District dropdown selection
districtSelect = ui.Select({
items: districtSelectItems,
placeholder: translate('Select District:'),
onChange: function(value) {
if (value === 'National Overview') {
resetToNationalView();
} else {
selectDistrict(value);
}
}
});

// Alternative: Map click selection
Map.onClick(function(coords) {
var point = ee.Geometry.Point(coords.lon, coords.lat);
var clickedDistrict = districts.filterBounds(point).first();
if (clickedDistrict) {
clickedDistrict.get('DISTRICT').evaluate(function(districtName) {
districtName = districtName.trim().toUpperCase();
selectDistrict(districtName);
});
} });</div>
</div>
</div>
</div>
<button class="carousel-control-prev" type="button" data-bs-target="#gallery-carousel" data-bs-slide="prev">
<span class="carousel-control-prev-icon" aria-hidden="true"></span>
<span class="visually-hidden">Previous</span>
</button>
<button class="carousel-control-next" type="button" data-bs-target="#gallery-carousel" data-bs-slide="next">
<span class="carousel-control-next-icon" aria-hidden="true"></span>
<span class="visually-hidden">Next</span>
</button>
</div>
</div>
</div>
</section>
</section>
<section id="references" class="level1">
<h1>References</h1>
<ol type="1">
<li><p>Hong, Y., Adler, R. &amp; Huffman, G., 2007. Use of satellite remote sensing data in the mapping of global landslide susceptibility. Natural Hazards, 43(2), pp.245–256. Available at: https://doi.org/10.1007/s11069-006-9104-z</p></li>
<li><p>Nepal in data, n.d. Major Languages Spoken As Mother Tongue in Nepal. Available at: https://nepalindata.com/insight/major-languages-spoken-as-mother-tongue-in-nepal/</p></li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/maheer-maps\.github\.io\/CASA25_Rasternauts\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<div style="text-align: left">
CASA0025 Group Project
</div>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Maheer-Maps/CASA25_Rasternauts" target="_blank">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>