[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Nepal Landslides Risk Application",
    "section": "",
    "text": "The project aims to develop an application using Google Earth Engine that policymakers can use to assess the landslide susceptibility in Nepal. The model identifies high hazard zones by using parameters like terrain, hydrology, soil, and land cover data. The model follows methodologies from “Use of satellite remote sensing data in the mapping of global landslide susceptibility” by Hong et al (2007). The machine learning model is also tested to validate its accuracy and practicality using the recent landslide points data from the Bipad Portal (Dates: 6-13 April, 2025).\n\n\n\nGlobal Modelling by Hong et al., 2007\n\n\n\n\n\nAlmost 80% of the total area of Nepal is prone to landslides (Department of Water Induced Disaster Prevention, 2015), so easily accessible research into which areas are most susceptible is motivated. Updating research to find which factors make areas most vulnerable to damaging landslides in Nepal provides information on the locations of vulnerable populations and critical infrastructure. This research must be easily interpretable for academics and, crucially, local administrators. Our application aims to bridge this disconnect by providing an accessible, Nepali-language platform for policymakers, planners, and stakeholders to visualize high susceptibility zones, and make informed decisions for mitigation and resilience.\n\n\n\nOur platform is designed for hybrid users across academia and specific administrative bodies involved in landslide management in Nepal. These users require scientifically robust yet accessible tools to develop policies. In the past, the gap between academic knowledge and local awareness limited the practical benefits of research—as seen during the 2015 earthquake and 2021 Melamchi floods. By delivering these models through a Nepali default website rather than papers, we aim to improve accessibility, utility, and real-world impact for those affected by landslides and responsible for crisis response."
  },
  {
    "objectID": "index.html#project-summary",
    "href": "index.html#project-summary",
    "title": "Nepal Landslides Risk Application",
    "section": "",
    "text": "The project aims to develop an application using Google Earth Engine that policymakers can use to assess the landslide susceptibility in Nepal. The model identifies high hazard zones by using parameters like terrain, hydrology, soil, and land cover data. The model follows methodologies from “Use of satellite remote sensing data in the mapping of global landslide susceptibility” by Hong et al (2007). The machine learning model is also tested to validate its accuracy and practicality using the recent landslide points data from the Bipad Portal (Dates: 6-13 April, 2025).\n\n\n\nGlobal Modelling by Hong et al., 2007\n\n\n\n\n\nAlmost 80% of the total area of Nepal is prone to landslides (Department of Water Induced Disaster Prevention, 2015), so easily accessible research into which areas are most susceptible is motivated. Updating research to find which factors make areas most vulnerable to damaging landslides in Nepal provides information on the locations of vulnerable populations and critical infrastructure. This research must be easily interpretable for academics and, crucially, local administrators. Our application aims to bridge this disconnect by providing an accessible, Nepali-language platform for policymakers, planners, and stakeholders to visualize high susceptibility zones, and make informed decisions for mitigation and resilience.\n\n\n\nOur platform is designed for hybrid users across academia and specific administrative bodies involved in landslide management in Nepal. These users require scientifically robust yet accessible tools to develop policies. In the past, the gap between academic knowledge and local awareness limited the practical benefits of research—as seen during the 2015 earthquake and 2021 Melamchi floods. By delivering these models through a Nepali default website rather than papers, we aim to improve accessibility, utility, and real-world impact for those affected by landslides and responsible for crisis response."
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Nepal Landslides Risk Application",
    "section": "Data",
    "text": "Data\n\n\n\nCategory\n\n\nDataset\n\n\nDescription\n\n\nSource\n\n\n\n\nGEE\n\n\nElevation/Slope\n\n\nNASA SRTM Digital Elevation 30m\n\n\nLink\n\n\n\n\nLand Cover\n\n\nMODIS Land Cover Type (2020)\n\n\nLink\n\n\n\n\nHydrology\n\n\nWWF HydroSHEDS flow accumulation\n\n\nLink\n\n\n\n\nSoil Texture\n\n\nOpenLandMap Soil Texture Class (USDA System)\n\n\nLink\n\n\n\n\nSoil Type\n\n\nOpenLandMap Clay Content\n\n\nLink\n\n\n\n\nPopulation Density\n\n\nGlobal Human Settlement Layer of spatial distribution of residential population\n\n\nLink\n\n\n\n\nOther\n\n\nHistorical Landslides\n\n\nOfficial reported landslide incident points (2011 - April 2025)\n\n\nLink\n\n\n\n\nCensus Population\n\n\nOfficial Population per District 2021 Census\n\n\nLink\n\n\n\n\nCountry Boundary\n\n\nOfficial boundary layer for Nepal\n\n\nLink\n\n\n\n\nDistricts Boundaries\n\n\nOfficial bouundaries of Nepal’s 77 districts\n\n\nLink"
  },
  {
    "objectID": "index.html#methodology",
    "href": "index.html#methodology",
    "title": "Nepal Landslides Risk Application",
    "section": "Methodology",
    "text": "Methodology\n\nSusceptibility Model\nTo recreate Hong et al.’s susceptibility model in GEE, we imported six environmental variables into a weighted linear combination. Each variable was normalized on a 0-1 scale, and in combination with the weights provided a susceptibility score for each pixel. Susceptibility was then normalized 0-1 for the whole of Nepal.\n\n\n\nSusceptibility Model Methodology\n\n\n\nSusceptibility Model Code - ADDED TEMPORARILY\n\n // Import shapefile for country boundaries\nvar filteredCountries = ee.FeatureCollection(\"projects/ee-testing-casa-25/assets/Nepal_boundary\");\nMap.centerObject(filteredCountries, 7);\n\n// DEM\nvar dem = ee.Image('USGS/SRTMGL1_003');\nvar clippedDem = dem.clip(filteredCountries);\n\n// Variable 1: SLOPE\nvar slope = ee.Terrain.slope(clippedDem);\nvar minMaxSlope = slope.reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: filteredCountries.geometry(),\n  scale: 250,\n  bestEffort: true\n});\nvar minSlope = ee.Number(minMaxSlope.get('slope_min'));\nvar maxSlope = ee.Number(minMaxSlope.get('slope_max'));\nprint(\"Min Slope:\", minSlope);\nprint(\"Max Slope:\", maxSlope);\nvar normSlope = slope.subtract(minSlope).divide(maxSlope.subtract(minSlope));\nMap.addLayer(normSlope, {min: 0, max: 1, palette: ['white', 'blue', 'green', 'yellow', 'red']}, 'Nomalised Slope', false);\n\n// Variable 2: ELEVATION\nvar elev = clippedDem;\nvar minMaxElevation = elev.reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: filteredCountries.geometry(),\n  scale: 250,\n  bestEffort: true\n});\nvar minElev = ee.Number(minMaxElevation.get('elevation_min'));\nvar maxElev = ee.Number(minMaxElevation.get('elevation_max'));\nprint(\"Min Elevation (m):\", minElev);\nprint(\"Max Elevation (m):\", maxElev);\nvar normElev = elev.subtract(minElev).divide(maxElev.subtract(minElev));\nMap.addLayer(normElev, {min: 0, max: 1, palette: ['white', 'blue', 'green', 'yellow', 'red']}, 'Nomalised Elevation', false);\n\n// Variable 3: MODIS land cover type and reclassification\nvar landcover = ee.ImageCollection(\"MODIS/061/MCD12Q1\")\n  .select(\"LC_Type1\")\n  .filterDate(\"2023-01-01\", \"2023-12-31\")\n  .first()\n  .clip(filteredCountries);\n\nvar reclassifiedLand = landcover.remap(\n  [0, 15, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 13, 17],\n  [0, 0, 0.1, 0.1, 0.1, 0.2, 0.2, 0.3, 0.4, 0.4, 0.5, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0]\n);\n\nvar minMaxLand = reclassifiedLand.reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: filteredCountries.geometry(),\n  scale: 250,\n  bestEffort: true\n});\nvar minLand = ee.Number(minMaxLand.get('remapped_min'));\nvar maxLand = ee.Number(minMaxLand.get('remapped_max'));\n\nMap.addLayer(reclassifiedLand, {min: 0, max: 1, palette: ['blue', 'green', 'yellow', 'red']}, \"Reclassified Land Cover\", false);\n\n// Variable 4a: Drainage Density\nvar flowAccum = ee.Image(\"WWF/HydroSHEDS/15ACC\").clip(filteredCountries);\nvar kernel = ee.Kernel.circle(5000, 'meters');\nvar threshold = 50;\nvar streamMask = flowAccum.gt(threshold);\nvar drainageDensity = streamMask.reduceNeighborhood({\n  reducer: ee.Reducer.mean(),\n  kernel: kernel\n});\nvar minMaxDensity = drainageDensity.reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: filteredCountries.geometry(),\n  scale: 250,\n  bestEffort: true\n});\nvar minDensity = ee.Number(minMaxDensity.get('b1_mean_min'));\nvar maxDensity = ee.Number(minMaxDensity.get('b1_mean_max'));\n\nvar normalizedDrainageDensity = drainageDensity.subtract(minDensity).divide(maxDensity.subtract(minDensity));\nMap.addLayer(normalizedDrainageDensity, {min: 0, max: 1, palette: ['white', 'green', 'blue']}, 'Normalised Drainage Density', false);\n\n// Variable 4b: Distance to Drainage\nvar streams = flowAccum.gt(threshold).selfMask();\nvar distanceToDrainage = streams.fastDistanceTransform().sqrt().clip(filteredCountries);\nvar minMax = distanceToDrainage.reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: filteredCountries.geometry(),\n  scale: 250,\n  bestEffort: true\n});\nvar minDist = ee.Number(minMax.get('distance_min'));\nvar maxDist = ee.Number(minMax.get('distance_max'));\n\nvar normalizedDistance = distanceToDrainage.subtract(minDist).divide(maxDist.subtract(minDist));\nnormalizedDistance = ee.Image(1).subtract(normalizedDistance);\nMap.addLayer(normalizedDistance, {min: 0, max: 1, palette: [\"blue\", \"yellow\", \"red\"]}, \"Normalized Distance to Drainage\", false);\n\n// Variable 5: Soil Texture (Original)\nvar soilTexture = ee.Image(\"OpenLandMap/SOL/SOL_TEXTURE-CLASS_USDA-TT_M/v02\").select(\"b0\").clip(filteredCountries);\nvar reclassifiedSoil = soilTexture.remap(\n [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n [3, 3, 3, 3, 2, 2, 2, 2, 1, 2, 1, 1]\n);\nreclassifiedSoil = ee.Image(4).subtract(reclassifiedSoil);\nvar minMaxSoilTexture = reclassifiedSoil.reduceRegion({\n reducer: ee.Reducer.minMax(),\n geometry: filteredCountries.geometry(),\n scale: 250,\n bestEffort: true\n});\n\nvar minSoil = ee.Number(minMaxSoilTexture.get('constant_min'));\nvar maxSoil = ee.Number(minMaxSoilTexture.get('constant_max'));\nprint(\"Min Soil:\", minSoil);\nprint(\"Max Soil:\", maxSoil);\nvar normalizedSoilTexture = reclassifiedSoil.subtract(minSoil).divide(maxSoil.subtract(minSoil));\nMap.addLayer(normalizedSoilTexture, {min: 0, max: 1, palette: [\"yellow\", \"green\", \"red\"]}, \"Normalised Soil Texture\", false);\n\n// Variable 6: Soil Type (Clay %)\nvar soilType = ee.Image(\"OpenLandMap/SOL/SOL_CLAY-WFRACTION_USDA-3A1A1A_M/v02\").clip(filteredCountries);\nsoilType = soilType.reduce(ee.Reducer.mean());\nvar minMaxClay = soilType.reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: filteredCountries.geometry(),\n  scale: 250,\n  bestEffort: true\n});\n\nvar minClay = ee.Number(minMaxClay.get('mean_min'));\nvar maxClay = ee.Number(minMaxClay.get('mean_max'));\nprint(\"Min Clay %:\", minClay);\nprint(\"Max Clay %:\", maxClay);\nvar normClay = soilType.subtract(minClay).divide(maxClay.subtract(minClay));\nMap.addLayer(normClay.select(0), {min: 0, max: 1, palette: [\"blue\", \"yellow\", \"red\"]}, \"Normalized Clay Percentage\", false);\n\n// Resample all layers\nvar targetScale = 1000;\nvar crs = 'EPSG:4326';\nnormSlope = normSlope.reproject({crs: crs, scale: targetScale});\nnormalizedDrainageDensity = normalizedDrainageDensity.reproject({crs: crs, scale: targetScale});\nnormalizedDistance = normalizedDistance.reproject({crs: crs, scale: targetScale});\nnormElev = normElev.reproject({crs: crs, scale: targetScale});\nnormClay = normClay.reproject({crs: crs, scale: targetScale});\nreclassifiedLand = reclassifiedLand.reproject({crs: crs, scale: targetScale});\nnormalizedSoilTexture = normalizedSoilTexture.reproject({crs: crs, scale: targetScale});\n\n// Verify ranges\nprint(normSlope.reduceRegion({reducer: ee.Reducer.minMax(), geometry: filteredCountries.geometry(), scale: 250, bestEffort: true}));\nprint(normalizedDrainageDensity.reduceRegion({reducer: ee.Reducer.minMax(), geometry: filteredCountries.geometry(), scale: 250, bestEffort: true}));\nprint(normalizedDistance.reduceRegion({reducer: ee.Reducer.minMax(), geometry: filteredCountries.geometry(), scale: 250, bestEffort: true}));\nprint(normElev.reduceRegion({reducer: ee.Reducer.minMax(), geometry: filteredCountries.geometry(), scale: 250, bestEffort: true}));\nprint(normClay.reduceRegion({reducer: ee.Reducer.minMax(), geometry: filteredCountries.geometry(), scale: 250, bestEffort: true}));\nprint(reclassifiedLand.reduceRegion({reducer: ee.Reducer.minMax(), geometry: filteredCountries.geometry(), scale: 250, bestEffort: true}));\nprint(normalizedSoilTexture.reduceRegion({reducer: ee.Reducer.minMax(), geometry: filteredCountries.geometry(), scale: 250, bestEffort: true}));\n\n// Landslide Susceptibility Model\nvar landslideRisk = normSlope.multiply(0.3)\n  .add(normalizedDrainageDensity.multiply(0.1))\n  // .add(normalizedDistance.multiply(0.1)) // optional\n  .add(normElev.multiply(0.1))\n  .add(normClay.multiply(0.2))\n  .add(reclassifiedLand.multiply(0.1))\n  .add(normalizedSoilTexture.multiply(0.2));\n\n// Rename the band to \"risk\"\nvar landslideRisk = landslideRisk.rename('risk');\n\nvar minMaxRiskLandslide = landslideRisk.reduceRegion({\n  reducer: ee.Reducer.minMax(),\n  geometry: filteredCountries.geometry(),\n  scale: 250,\n  bestEffort: true\n});\n\nvar minRisk = ee.Number(minMaxRiskLandslide.get('risk_min'));\nvar maxRisk = ee.Number(minMaxRiskLandslide.get('risk_max'));\nvar normalizedLandslideRisk = landslideRisk.subtract(minRisk).divide(maxRisk.subtract(minRisk));\n\nMap.addLayer(normalizedLandslideRisk.select(0), {\n  min: 0,\n  max: 1,\n  palette: ['green', 'yellow', 'red']\n}, \"Normalized Landslide Risk\");\n\n\n\n\nRandom Forest Model\nTo find populated areas most susceptible to landslides, we masked our environmental variables to populated areas, and trained a random forest classifier on landslide and randomly generated non-landslide points from Bipad Portal. Each pixel was scored based on the proportion of decision trees voting landslide.\n\n\n\nRandom Forest Model Methodology"
  },
  {
    "objectID": "index.html#interface",
    "href": "index.html#interface",
    "title": "Nepal Landslides Risk Application",
    "section": "Interface",
    "text": "Interface\nThe website provides an intuitive, multilingual interface combining expertise and data into robust models, offering comparative visualizations and statistical summaries. The platform prioritizes clarity through map-based dashboards and toggleable language options to enhance accessibility and local impact.\n\n\n\n\n\nDistrict Level View\n\n\n\n\n\n\n\n\nMethodology View"
  },
  {
    "objectID": "index.html#the-application",
    "href": "index.html#the-application",
    "title": "Nepal Landslides Risk Application",
    "section": "The Application",
    "text": "The Application\n\nHow it Works\n\n1. Data Preparation and Precomputations\nTo handle complex computations, separate scripts were developed for the two methodologies explained above. Results are imported into the app as precomputed layers.\nImported Precomputed Layers:\n\nEnvironmental Landslide Susceptibility: Maps susceptibility using environmental variables.\nNormalized Landslide Susceptibility: Adjusted for population exposure.\nRandom Forest Landslide Probability: ML-based risk focused on populated areas.\n\nDistrict-Level Aggregation:\nA dedicated script was built to aggregate historical reported landslide data with impact metrics (e.g., incidents, deaths, injuries, destroyed infrastructure), alongside population and susceptibility metrics per district. It also includes engineered metrics such as incidents per km² and nearest districts (determined via spatial proximity of centroids) for comparative analysis.\n  // Compute distances to other districts and find two nearest neighbors using precomputed centroids\n  var districtsWithDistance = districtFactors.map(function(otherDistrict) {\n    var otherName = otherDistrict.get('DISTRICT');\n    var lon2 = ee.Number(otherDistrict.get('centroid_lon'));\n    var lat2 = ee.Number(otherDistrict.get('centroid_lat'));\n\n    // Approximate distance using Euclidean distance in lat/lon \n    var distance = lon1.subtract(lon2).pow(2).add(lat1.subtract(lat2).pow(2)).sqrt();\n    return otherDistrict.set('distance', distance);\n  });\n\n  var nearbyDistricts = districtsWithDistance\n    .filter(ee.Filter.neq('DISTRICT', districtName))\n    .sort('distance')\n    .limit(2);\n\n  // Extract the two nearest neighbors\n  var neighbor1 = nearbyDistricts.first();\n  var neighbor2 = nearbyDistricts.toList(2).get(1);\n\n\n2. Interactive Visualization and Analysis\n\n\nNational Overview\nAt startup, national-level statistics are displayed, highlighting aggregated data. A pie chart shows population risk distribution across susceptibility zones (Low, Medium, High), and a bar chart lists the top 5 districts by impact metric, allowing users to switch metrics and zoom into a district by clicking a bar.\n\nsusceptibility zones\nSusceptibility zones are defined as Low (&lt;0.3), Medium (0.3–0.5), and High (&gt;0.5), identified by analyzing the distribution of susceptibility values from the built Susceptibility model.\n\n// Generate a histogram of susceptibility values\nvar histogram = LandslideSusceptibility.reduceRegion({\n  reducer: ee.Reducer.histogram({min: 0, max: 1, steps: 100}),\n  geometry: NepalBoundary.geometry(),\n  scale: 1000, // Match the scale used in the app for consistency\n  maxPixels: 1e10,\n  bestEffort: true\n});\n\n// Extract the histogram data\nvar histogramDict = ee.Dictionary(histogram.get('susceptibility'));\nvar values = ee.List(histogramDict.get('histogram')); // Frequency counts\nvar bucketEdges = ee.List(histogramDict.get('bucketMeans')); // Bin centers\n\n// Print the histogram for analysis\nprint('Histogram of Susceptibility Values:', histogram);\n\n// Define susceptibility zones based on histogram-derived thresholds\nvar thresholdZones = LandslideSusceptibility\n  .where(LandslideSusceptibility.lt(0.3), 1) // Low Risk: &lt; 0.3\n  .where(LandslideSusceptibility.gte(0.3).and(LandslideSusceptibility.select('slope').lte(0.5)), 2) // Medium Risk: 0.3–0.5\n  .where(LandslideSusceptibility.gt(0.5), 3) // High Risk: &gt; 0.5\n  .rename('zone')\n  .updateMask(LandslideSusceptibility.mask())\n  .clip(NepalBoundary);\n\n\n\nDistrict-Level Analysis:\nThis view provides detailed district analysis, showing key metrics like average susceptibility, population, and incidents per km², alongside comparisons with national averages and the two nearest districts. Historical landslides are visualized on the map, with popups displaying aggregated details within a 300m radius of a clicked point.\n\n\nMethodology overview:\nThis view allows users to compare the two methodologies (Environmental Susceptibility and RF) using a split panel. It displays the RF probability map and normalized risk map for populated areas, with a draggable divider for spatial comparison, focusing on population exposure.\n// Initialize split maps with layers\nvar leftMap = ui.Map();\nvar rightMap = ui.Map();\n\n// Add risk layers to split maps\nvar leftProbabilityLayer = ui.Map.Layer(probabilityLayer.getEeObject(), probabilityLayer.getVisParams(), translate('RF Landslide Probability (Populated Areas)'));\nleftMap.layers().add(leftProbabilityLayer);\nvar rightNormalizedRiskLayer = ui.Map.Layer(normalizedRiskLayer.getEeObject(), normalizedRiskLayer.getVisParams(), translate('Landslide Susceptibility (Populated Areas)'));\nrightMap.layers().add(rightNormalizedRiskLayer);\n\n// Link maps for synchronized zooming and panning\nvar mapLinker = ui.Map.Linker([leftMap, rightMap]);\n\n// Set up the split panel for comparison\nvar splitPanel = ui.SplitPanel({\n firstPanel: leftMap,\n secondPanel: rightMap,\n orientation: 'horizontal',\n wipe: true\n});\n\n\n3. insights and objectives\nThe app provides actionable insights for disaster preparedness in Nepal by identifying high-risk districts and population exposure. It supports:\n\nRisk Prioritization: Highlights districts with high susceptibility or incident rates (e.g., top 5 districts by deaths) to guide resource allocation.\nLocalized Insights: Enables district-level analysis for targeted planning and response, benefiting community preparedness efforts.\nAcademic Research: Unlike traditional landslide models in academic papers, this app provides an interactive platform for exploring risk dynamics through a comparison of Environmental Susceptibility and Random Forest methodologies, leveraging incidents data. By masking to populated areas, it focuses on human exposure, as official records often under-report incidents in uninhabited regions, ensuring more accurate risk assessment and model comparison for populated zones.\n\n\n\n4. Limitations and Potential Expansion\n\nModel Variables: The Environmental Susceptibility model uses six variables—slope, elevation, land cover, soil texture, clay content, and drainage density—with weights derived from literature. Future improvements could involve a more comprehensive literature review to identify additional influential factors and the integration of advanced modeling techniques.\nStatic Models: Current models are precomputed, limiting adaptability to changing environmental conditions. Adding dynamic updates with live data (e.g., rainfall, land use changes) could improve accuracy and responsiveness.\nGranularity of Analysis: The app focuses on district-level analysis, but more granular insights (e.g., at the village or ward level) could improve localized planning\nReport Export: The app lacks a feature to export analysis reports, which would be valuable for stakeholders to document and share findings.\n\n\n\n\nDemo\nThe application runs on Google Earth Engine, allowing users to visualise landslide risk across Nepal dynamically. Users can zoom in to specific districts, interpret risk zones, and overlay incident data to validate model predictions. The tool is built for scalability and may be adapted for other regions facing similar geological threats.\n\n\n\n\n\n\nKey Features Beyond the Demo\nWhile our demo showcases the app’s core functionality, several critical features work behind the scenes to enhance its performance and reliability. In this section, we highlight key capabilities implemented to optimize efficiency and ensure a seamless user experience.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMulti-Language Support\nDesigned with the end user in mind, the app supports Nepal’s primary languages—Nepali (~44%), Maithili (~12%), and Bhojpuri (~6%)—ensuring accessibility for diverse users, including those with low English fluency.\n\n\n\n\n\n\n// Language selection dropdown\nvar languageSelect = ui.Select({\nitems: [\n{label: 'English', value: 'English'},\n{label: 'Nepali', value: 'Nepali'},\n{label: 'Maithili', value: 'Maithili'},\n{label: 'Bhojpuri', value: 'Bhojpuri'}\n],\nonChange: function(value) {\nresetToNationalView();\nupdateLanguage(value);\n}\n});\n/ Translation dictionary (Sample)\nvar LANGUAGE_TRANSLATIONS = {\n'Nepali': { 'Click on the map or select from list:': 'नक्सामा क्लिक गर्नुहोस् वा सूचीबाट चयन गर्नुहोस्:' },\n'Maithili': { 'Click on the map or select from list:': 'नक्शा पर क्लिक करू या सूची सँ चुनू' },\n'Bhojpuri': { 'Click on the map or select from list:': 'नक्शा प क्लिक करीं या सूची से चुनीं' }\n}; \n\n\n\nEfficient Caching\nTo avoid redundant computations, the app Leverages local memory for server-side calculations, ensuring responsiveness even with large datasets.\n\n\n\n\n\n\n// Cache national statistics at startup\nee.Dictionary({\nincidentCount: districtFactors.aggregate_sum('incidentCount'),\ndeaths: districtFactors.aggregate_sum('deaths'),\ninjuries: districtFactors.aggregate_sum('injuries'),\ninfrastructureDestroyed: districtFactors.aggregate_sum('infraDestroyed')\n}).evaluate(\nfunction(values) {\n// Cached values used in national overview for quick loading\nnationalStats.incidentCount = Number(values.incidentCount) || 0; // Total incidents\nnationalStats.deaths = Number(values.deaths) || 0; // Total deaths\nnationalStats.injuries = Number(values.injuries) || 0; // Total injuries\nnationalStats.infrastructureDestroyed = Number(values.infrastructureDestroyed) || 0; // Total infrastructure damage\ninitializeAppAfterCaching();\n}\n);\n\n\n\nRobust Error Handling\nThe app handles clicks outside study areas and data issues with clear messages to keep users informed and engaged, preventing crashes and enhancing reliability.\n\n\n\n\n\n\n// Handle clicks outside Nepal\nNepalBoundary.geometry().contains(point).evaluate(function(isInside) {\nif (!isInside) {\nStatisticsPanel.clear();\nvar widgets = controlPanel.widgets();\nif (widgets.indexOf(districtInstructionLabel) !== -1) {\nwidgets.remove(districtInstructionLabel);\n}\nif (widgets.indexOf(districtSelectPanel) !== -1) {\nwidgets.remove(districtSelectPanel);\n}\nStatisticsPanel.add(ui.Label(translate('Click outside Nepal boundary. Please select a point within Nepal.'), STYLES.SUBTITLE));\nStatisticsPanel.add(ui.Button({\nlabel: translate('Reset to National Overview'),\nonClick: function() {\nresetToNationalView();\n},\nstyle: { margin: '10px auto', stretch: 'horizontal', textAlign: 'center' }\n}));\n} });\n\n\n\nOptimal Rendering\nThe app enhances speed and user experience by clipping and rendering high-resolution raster data for the selected district only, rather than the entire country.\n\n\n\n\n\n\n// Highlight and clip layers for the selected district\nfunction highlightDistrict(district) {\n// Simplify geometry to reduce computation\nvar districtGeometry = district.geometry().simplify({maxError: 100});\n// Clip layers to district for efficient rendering\nvar clippedLandslide = landslidePoints.filterBounds(districtGeometry);\nvar clippedSus = LandslideSusceptibility.clip(districtGeometry);\n\nclippedLandslideFeatures = null;\nclippedLandslide.evaluate(function(features) {\nclippedLandslideFeatures = features.features || [];\n});\n\nclearMapLayersExceptHighlight();\n// Add clipped layers to map\nvar susceptibilityLayerclip = ui.Map.Layer(clippedSus, {min: 0, max: 1, palette: [STYLES.COLORS.LOW_RISK, STYLES.COLORS.MEDIUM_RISK, STYLES.COLORS.HIGH_RISK]});\nMap.layers().add(susceptibilityLayerclip);\n}\n\n\n\nCustom Basemaps and Streamlined Controls\nThe app enhances the user experience by customizing the basemap to focus on essential geographic data, modifying road displays (e.g., highways, arterial, and local roads) to reduce visual clutter and removing unneeded base elements like saturation. Additionally, main map controls (e.g., zoom, map type, scale, fullscreen) are hidden to provide a distraction-free interface.\n\n\n\n\n\n\n// Customize basemap to reduce visual clutter\nvar roadNetwork = [\n{stylers: [{saturation: -100}]}, // Desaturate basemap for focus on data layers\n{featureType: 'road.highway', elementType: 'geometry.fill', stylers: [{color: '#000055'}, {weight: 0.1}]}, // Simplify highway display\n{featureType: 'road.highway', elementType: 'geometry.stroke', stylers: [{color: '#000000'}, {weight: 0.1}]},\n{featureType: 'road.arterial', elementType: 'geometry', stylers: [{color: '#FF0000'}, {weight: 0.1}]}, // Simplify arterial roads\n{featureType: 'road.local', elementType: 'geometry', stylers: [{color: '#00FF55'}, {weight: 0.1}]} // Simplify local roads\n];\nMap.setOptions('roadNetwork', { roadNetwork: roadNetwork });\n\n// Hide main map controls for a distraction-free interface\nMap.setControlVisibility({\nzoomControl: false, // Disable zoom control\nmapTypeControl: false, // Disable map type selector\nscaleControl: false, // Disable scale control\nfullscreenControl: false // Disable fullscreen control\n});\nMap.drawingTools().setShown(false); // Hide drawing tools\n\n\n\n\nSummary Popups\nClicking a landslide point in district view displays a popup with aggregated details, aiding understanding of past events at specific locations.\n\n\n\n\n\n\n// Detect landslide points within buffer and aggregate data\nvar clickRadius = 0.0027; // ~300 meters\nvar matchingFeatures = [];\nclippedLandslideFeatures.forEach(function(feature) {\nvar featureCoords = feature.geometry.coordinates;\nvar distance = Math.sqrt(\nMath.pow(clickLon - featureLon, 2) + Math.pow(clickLat - featureLat, 2)\n);\nif (distance &lt; clickRadius) {\nmatchingFeatures.push(feature);\n}\n});\n\nif (matchingFeatures.length &gt; 0) {\nvar totalDeaths = 0, totalInjuries = 0, incidentCount = matchingFeatures.length;\nmatchingFeatures.forEach(function(feature) {\nvar props = feature.properties || {};\ntotalDeaths += props.peopleDeathCount || 0;\ntotalInjuries += props.peopleInjuredCount || 0;\n});\nshowLandslidePopup({ incidentCount: incidentCount, totalDeaths: totalDeaths, totalInjuries: totalInjuries });\n}\n\n// Display aggregated data in popup\nfunction showLandslidePopup(aggregatedData, coords) {\nvar titleTemplate = translate('Landslide Events ({0} Incidents)');\nvar title = titleTemplate.replace('{0}', aggregatedData.incidentCount);\ncontentPanel.add(ui.Label(title, { fontSize: '16px', fontWeight: 'bold' }));\ncontentPanel.add(createRow('Deaths:', aggregatedData.totalDeaths));\ncontentPanel.add(createRow('Injuries:', aggregatedData.totalInjuries));\n}\n\n\n\nInteractive Analysis\nUsers can interact with districts by clicking on the map, selecting from a dropdown, or using connected charts, enabling seamless data exploration.\n\n\n\n\n\n\n// Chart interaction in national overview\ntopDistrictsChart.onClick(function(district) {\nif (district) {\nvar originalDistrictName = district.toUpperCase();\nselectDistrict(originalDistrictName);\n}\n});\n\n// Alternative: District dropdown selection\ndistrictSelect = ui.Select({\nitems: districtSelectItems,\nplaceholder: translate('Select District:'),\nonChange: function(value) {\nif (value === 'National Overview') {\nresetToNationalView();\n} else {\nselectDistrict(value);\n}\n}\n});\n\n// Alternative: Map click selection\nMap.onClick(function(coords) {\nvar point = ee.Geometry.Point(coords.lon, coords.lat);\nvar clickedDistrict = districts.filterBounds(point).first();\nif (clickedDistrict) {\nclickedDistrict.get('DISTRICT').evaluate(function(districtName) {\ndistrictName = districtName.trim().toUpperCase();\nselectDistrict(districtName);\n});\n} });\n\n\n\n\n\nPrevious\n\n\n\nNext"
  }
]